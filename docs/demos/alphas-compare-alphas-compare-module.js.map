{"version":3,"sources":["./src/app/features/performance/alphas-compare/alphas-compare.component.ts","./src/app/features/performance/alphas-compare/alphas-compare.component.html","./src/app/features/performance/alphas-compare/alpha-1-toggle/alpha-1-toggle.component.ts","./src/app/features/performance/alphas-compare/alpha-1-toggle/alpha-1-toggle.component.html","/home/runner/work/rx-angular/rx-angular/node_modules/templateAlpha0/__ivy_ngcc__/fesm2015/rx-angular-template.js","/home/runner/work/rx-angular/rx-angular/node_modules/util/node_modules/inherits/inherits_browser.js","./src/app/features/performance/alphas-compare/alphas-compare.routes.ts","./src/app/features/performance/alphas-compare/alpha-0-toggle/alpha-0-toggle.component.ts","./src/app/features/performance/alphas-compare/alpha-0-toggle/alpha-0-toggle.component.html","/home/runner/work/rx-angular/rx-angular/node_modules/util/support/isBufferBrowser.js","./src/app/features/performance/alphas-compare/alpha-0-toggle/alpha-0-toggle.module.ts","./src/app/features/performance/alphas-compare/alpha-1-toggle/alpha-1-toggle.module.ts","/home/runner/work/rx-angular/rx-angular/node_modules/util/util.js","/home/runner/work/rx-angular/rx-angular/node_modules/templateAlpha1/__ivy_ngcc__/fesm2015/rx-angular-template.js","./src/app/features/performance/alphas-compare/alphas-compare.module.ts"],"names":[],"mappings":"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AS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAa;AAC3C,yCAAyC,2EAAoB,IAAI,gEAAS;AAC1E,UAAU,+CAAE;AACZ;AACA,yCAAyC,kDAAa;AACtD,8DAA8D,2EAAoB;AAClF;AACA;AACA;AACA,IAAI,0DAAG;AACP;AACA,mBAAmB,+CAAE;AACrB;AACA;AACA;AACA;AACA,uBAAuB,+CAAE;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,6DAAM,0BAA0B,gEAAS,eAAe,2EAAoB,IAAI,0DAAG,wBAAwB,qEAAc,aAAa,0DAAG,sCAAsC,iEAAU;AAC7L;AACA,eAAe,0CAAK;AACpB,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,iDAAY;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oBAAoB;AAC1E;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,2BAA2B,mBAAmB;AAC9C;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,IAAI;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,CAAC;AACD;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAA0C;AACrD;AACA;AACA;AACA,WAAW,OAAO;AAClB,iBAAiB,iCAAiC;AAClD,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAU;AACjC,yCAAyC,iDAAY;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,0DAAG;AAC5C;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe,iDAAI;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;AACb,6BAA6B,iDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAc;AACjC,SAAS;AACT,mCAAmC;AACnC,gBAAgB,qDAAQ;AACxB,uBAAuB,mDAAc;AACrC;AACA,oDAAoD,aAAa,WAAW;AAC5E;AACA;AACA;AACA;AACA,iCAAiC,EAAE;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,aAAa;AACb,yBAAyB,iDAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAc;AAC7B,KAAK;AACL;AACA;AACA,mBAAmB,mDAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+BAA+B,+CAAU;AACzC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;;AAEjD;AACA,oBAAoB,4DAAuB;AAC3C,aAAa,kDAAa;AAC1B,iBAAiB,mDAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;;AAEA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uDAAuD;AACvD,6BAA6B,iDAAI;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA,6BAA6B,EAAE;AAC/B;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,6BAA6B,iDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,6BAA6B,iDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+CAAU;AAC3C,QAAQ,iDAAI;AACZ;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+CAAU;AAC3C,QAAQ,iDAAI;AACZ;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+CAAU;AAC3C,QAAQ,iDAAI;AACZ;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,6BAA6B,iDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,+BAA+B,gEAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,mEAAmE;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,oDAAoD,GAAG;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mDAAmD,GAAG;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,4BAA4B,2EAAoC,IAAI;AAClH,iBAAiB,0DAAmB,EAAE,4CAA4C;AAClF;AACA,KAAK,OAAO,+DAAiB;AAC7B;AACA,WAAW,wDAAU,GAAG,wDAAU,uBAAuB,+DAAiB;AAC1E;;AAEA;AACA;AACA;AACA,kBAAkB,8DAAuB,EAAE,mBAAmB;AAC9D,kBAAkB,8DAAuB,EAAE,0CAA0C,gCAAgC,EAAE,iBAAiB;;AAExI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC,+DAAwB,CAAC,+DAAwB,GAAG,+DAAwB,CAAC,yDAAkB,GAAG,+DAAwB,CAAC,8DAAuB,GAAG;AAC3O,oBAAoB,+DAAwB,EAAE,8DAA8D,0DAA0D,EAAE;AACxK;AACA,KAAK,OAAO,+DAAiB,EAAE;AAC/B,KAAK,OAAO,yDAAW,EAAE;AACzB,KAAK,OAAO,8DAAgB;AAC5B;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,eAAe,wDAAU,GAAG,wDAAU,uBAAuB,+DAAiB;AAC9E,QAAQ,yDAAW;AACnB,QAAQ,8DAAgB;AACxB;;AAEA;AACA;AACA;AACA,iBAAiB,8DAAuB,EAAE,kBAAkB;AAC5D,iBAAiB,8DAAuB,EAAE,yCAAyC,+BAA+B,EAAE,EAAE;;AAEtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAY;AAC5C,2BAA2B,oDAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAG;AACrB;AACA;AACA;AACA,0EAA0E,0CAA0C,+DAAwB,CAAC,wDAAiB,GAAG;AACjK,8BAA8B,+DAAwB,EAAE,0EAA0E,gCAAgC,EAAE;AACpK;AACA,KAAK,OAAO,wDAAU;AACtB;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,yBAAyB,wDAAU,GAAG,wDAAU,uBAAuB,wDAAU;AACjF;;AAEA;AACA;AACA;AACA,2BAA2B,8DAAuB,EAAE,4BAA4B;AAChF,2BAA2B,8DAAuB,EAAE,mDAAmD,yCAAyC,EAAE,EAAE;;AAEpJ;AACA;AACA,sBAAsB,8DAAuB,EAAE,uBAAuB;AACtE,sBAAsB,8DAAuB,EAAE,8CAA8C,oCAAoC,EAAE,yDAAyD;AAC5L,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,kDAAI;AAClB,gBAAgB,4BAA4B;AAC5C,KAAK,gBA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ACR,YAAY,EAAE,CAAC,+EAAqB,CAAC;gBACrC,OAAO,EAAE,CAAC,4DAAY,EAAE,6DAAc,EAAE,6GAAmB,CAAC;gBAC5D,OAAO,EAAE,CAAC,+EAAqB,CAAC;aACjC;;;;;;;;;;;;;;ACVD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyC;AACM;AACC;AACmB;AACwC;;AAOpG,MAAM,kBAAkB;;iGAAlB,kBAAkB;8JAAlB,kBAAkB,kBAHpB,CAAC,4DAAY,EAAE,6DAAc,EAAE,6GAAmB,CAAC;mIAGjD,kBAAkB,mBAJd,+EAAqB,aAC1B,4DAAY,EAAE,6DAAc,EAAE,6GAAmB,aACjD,+EAAqB;6FAEpB,kBAAkB;cAL9B,sDAAQ;eAAC;gBACR,YAAY,EAAE,CAAC,+EAAqB,CAAC;gBACrC,OAAO,EAAE,CAAC,4DAAY,EAAE,6DAAc,EAAE,6GAAmB,CAAC;gBAC5D,OAAO,EAAE,CAAC,+EAAqB,CAAC;aACjC;;;;;;;;;;;;;ACVD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,uBAAuB,SAAS;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,KAAK;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAO,CAAC,gCAAoB;;AAE/C;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,mBAAmB,mBAAO,CAAC,sBAAU;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACzkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0G;AACyB;AACkC;;AAErK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACwC;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oBAAoB;AAC1E;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,2BAA2B,mBAAmB;AAC9C;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,IAAI;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAA0C;AACrD;AACA;AACA;AACA,WAAW,OAAO;AAClB,iBAAiB,iCAAiC;AAClD,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAU;AACjC,yCAAyC,iDAAY;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAG,OAAO,gEAAU;AACtD;AACA,YAAY,gEAAU;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,2EAAoB,IAAI,0DAAG;AAClD;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAa;AAC3C;AACA,yCAAyC,2EAAoB,IAAI,gEAAS;AAC1E,UAAU,+CAAE;AACZ,+DAA+D,0DAAG;AAClE,yCAAyC,kDAAa;AACtD,8DAA8D,2EAAoB;AAClF;AACA;AACA;AACA,IAAI,0DAAG;AACP;AACA,mBAAmB,+CAAE;AACrB;AACA;AACA;AACA;AACA,uBAAuB,+CAAE;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,6DAAM,0BAA0B,gEAAS,eAAe,2EAAoB,IAAI,0DAAG,oDAAoD,+DAAQ,wCAAwC,iEAAU;AACrM;AACA,eAAe,0CAAK;AACpB,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,iDAAY;AACnC;AACA;AACA;AACA;AACA;;AAEA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;;AAEb,qCAAqC,+CAAU;AAC/C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;AAED;AACA,8BAA8B,+CAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED,8BAA8B,+CAAU;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,aAAa;;AAEb,mCAAmC,+CAAU;AAC7C;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED,sCAAsC,+CAAU;AAChD;AACA,yBAAyB,EAAE;AAC3B;AACA;AACA;AACA,KAAK;AACL,kBAAkB;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,8BAA8B,iDAAiD;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAAuD;AACvD,6BAA6B,iDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAc;AACtB;AACA,mFAAmF,gEAAS,gBAAgB,0DAAG,aAAa,0DAAG;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAc;AACtB;AACA;AACA,mFAAmF,gEAAS,gBAAgB,0DAAG,aAAa,0DAAG;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,+BAA+B,gEAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,mEAAmE;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,oDAAoD,GAAG;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mDAAmD,GAAG;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,4BAA4B,2EAAoC,IAAI;AAClH,iBAAiB,0DAAmB,EAAE,4CAA4C;AAClF;AACA,KAAK,OAAO,+DAAiB;AAC7B;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,kDAAI;AAClB,gBAAgB,4BAA4B;AAC5C,KAAK,gBAAgB,UAAU,OAAO,+DAAwB,EAAE,EAAE,EAAE,QAAQ,EAAE;AAC9E;AACA,KAAK,OAAO,+DAAiB;AAC7B;;AAEA;AACA;AACA;AACA,kBAAkB,8DAAuB,EAAE,mBAAmB;AAC9D,kBAAkB,8DAAuB,EAAE,0CAA0C,gCAAgC,EAAE,iBAAiB;AACxI,cAAc,oDAAoD,gEAAyB,cAAc,gDAAgD,EAAE,EAAE;AAC7J,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,sDAAQ;AACtB;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC,+DAAwB,CAAC,+DAAwB,GAAG,+DAAwB,CAAC,yDAAkB,GAAG,+DAAwB,CAAC,8DAAuB,GAAG;AAC3O,oBAAoB,+DAAwB,EAAE,8DAA8D,oJAAoJ,gCAAgC;AAChS;AACA,KAAK,OAAO,+DAAiB,EAAE;AAC/B,KAAK,OAAO,yDAAW,EAAE;AACzB,KAAK,OAAO,8DAAgB;AAC5B;AACA;AACA,KAAK,OAAO,+DAAiB,EAAE;AAC/B,KAAK,OAAO,yDAAW,EAAE;AACzB,KAAK,OAAO,8DAAgB;AAC5B;AACA;AACA,aAAa,OAAO,mDAAK,EAAE;AAC3B,gBAAgB,OAAO,mDAAK,4BAA4B;AACxD,qBAAqB,OAAO,mDAAK,EAAE;AACnC,kBAAkB,OAAO,mDAAK,EAAE;AAChC,qBAAqB,OAAO,mDAAK,EAAE;AACnC;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB;AACA;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,OAAO,+DAAwB,EAAE,GAAG,OAAO,yDAAkB,EAAE,GAAG,OAAO,8DAAuB,EAAE,EAAE,EAAE,GAAG;AACxI,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB;AACA,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS,GAAG,EAAE,EAAE;;AAEhB;AACA;AACA;AACA,iBAAiB,8DAAuB,EAAE,kBAAkB;AAC5D,iBAAiB,8DAAuB,EAAE,yCAAyC,+BAA+B,EAAE,EAAE;AACtH,cAAc,oDAAoD,gEAAyB,aAAa,wDAAwD,EAAE,EAAE;AACpK,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,sDAAQ;AACtB;AACA;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAY;AAC5C,2BAA2B,oDAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAG;AACrB;AACA;AACA;AACA,0EAA0E,0CAA0C,+DAAwB,CAAC,wDAAiB,GAAG;AACjK,8BAA8B,+DAAwB,EAAE,0EAA0E,gCAAgC,EAAE;AACpK;AACA,KAAK,OAAO,wDAAU;AACtB;AACA;AACA,KAAK,OAAO,wDAAU;AACtB;AACA;AACA,cAAc,OAAO,mDAAK,sBAAsB;AAChD;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB,gBAAgB,wBAAwB;AACxC,KAAK,gBAAgB,UAAU,OAAO,wDAAiB,EAAE,EAAE,EAAE,GAAG;AAChE,kBAAkB,mDAAK;AACvB;AACA,SAAS,GAAG,EAAE,EAAE;;AAEhB;AACA;AACA;AACA,2BAA2B,8DAAuB,EAAE,4BAA4B;AAChF,2BAA2B,8DAAuB,EAAE,mDAAmD,yCAAyC,EAAE,EAAE;AACpJ,cAAc,oDAAoD,gEAAyB,uBAAuB,4EAA4E,EAAE,EAAE;AAClM,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,sDAAQ;AACtB;AACA;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B,iBAAiB,OAAO;AACxB;AACA;AAC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","file":"alphas-compare-alphas-compare-module.js","sourcesContent":["import { Component } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { environment } from '../../../../environments/environment';\n\n@Component({\n  selector: 'rxa-alphas-compare',\n  templateUrl: './alphas-compare.component.html',\n  changeDetection: environment.changeDetection,\n})\nexport class AlphasCompareComponent {\n  show0PushAutoTest = false;\n  show0Push = false;\n  show0LetAutoTest = false;\n  show0Let = false;\n  show1PushAutoTest = false;\n  show1Push = false;\n  show1LetAutoTest = false;\n  show1Let = false;\n\n  toggle0Push() {\n    this.show0Push = !this.show0Push;\n  }\n  toggle0PushAutoTest() {\n    this.show0PushAutoTest = !this.show0PushAutoTest;\n  }\n  toggle0Let() {\n    this.show0Let = !this.show0Let;\n  }\n  toggle0LetAutoTest() {\n    this.show0LetAutoTest = !this.show0LetAutoTest;\n  }\n\n  toggle1Push() {\n    this.show1Push = !this.show1Push;\n  }\n  toggle1PushAutoTest() {\n    this.show1PushAutoTest = !this.show1PushAutoTest;\n  }\n\n  toggle1Let() {\n    this.show1Let = !this.show1Let;\n  }\n  toggle1LetAutoTest() {\n    this.show1LetAutoTest = !this.show1LetAutoTest;\n  }\n}\n","<h1>Alpha 0 vs Beta 0 (To enable Alpha 1 check alpha-1-toggle.module)</h1>\n<div class=\"row w-100\">\n  <div class=\"col-sm-12 col-md-3\">\n    <div style=\"margin-bottom: 16px\">\n      <button mat-raised-button color=\"primary\" (click)=\"toggle0PushAutoTest()\">\n        Run Auto test for Push pipe in Alpha 0\n      </button>\n    </div>\n    <div style=\"margin-bottom: 16px\">\n      <button mat-raised-button [unpatch] color=\"secondary\" (click)=\"toggle0Push()\">\n        Open Manual test for Push pipe in Alpha 0\n      </button>\n    </div>\n    <rxa-alpha0\n      *ngIf=\"show0PushAutoTest\"\n      [auto]=\"true\"\n      [type]=\"'push'\"\n    ></rxa-alpha0>\n    <rxa-alpha0 *ngIf=\"show0Push\" [auto]=\"false\" [type]=\"'push'\"></rxa-alpha0>\n  </div>\n  <div class=\"col-sm-12 col-md-3\">\n    <div style=\"margin-bottom: 16px\">\n      <button mat-raised-button color=\"primary\" (click)=\"toggle0LetAutoTest()\">\n        Run Auto test for Let in Alpha 0\n      </button>\n    </div>\n    <div style=\"margin-bottom: 16px\">\n      <button mat-raised-button color=\"secondary\" (click)=\"toggle0Let()\">\n        Open Manual test for Let in Alpha 0\n      </button>\n    </div>\n    <rxa-alpha0\n      *ngIf=\"show0LetAutoTest\"\n      [auto]=\"true\"\n      [type]=\"'rxLet'\"\n    ></rxa-alpha0>\n    <rxa-alpha0 *ngIf=\"show0Let\" [auto]=\"false\" [type]=\"'rxLet'\"></rxa-alpha0>\n  </div>\n\n  <div class=\"col-sm-12 col-md-3\">\n    <div style=\"margin-bottom: 16px\">\n      <button mat-raised-button color=\"primary\" (click)=\"toggle1PushAutoTest()\">\n        Run Auto test for Push in Alpha 1\n      </button>\n    </div>\n    <div style=\"margin-bottom: 16px\">\n      <button mat-raised-button color=\"secondary\" (click)=\"toggle1Push()\">\n        Open Manual test for Push pipe in Alpha 1\n      </button>\n    </div>\n    <rxa-alpha1\n      *ngIf=\"show1PushAutoTest\"\n      [auto]=\"true\"\n      [type]=\"'push'\"\n    ></rxa-alpha1>\n    <rxa-alpha1 *ngIf=\"show1Push\" [auto]=\"false\" [type]=\"'push'\"></rxa-alpha1>\n  </div>\n  <div class=\"col-sm-12 col-md-3\">\n    <div style=\"margin-bottom: 16px\">\n      <button mat-raised-button color=\"primary\" (click)=\"toggle1LetAutoTest()\">\n        Run Auto test for Let in Alpha 1\n      </button>\n    </div>\n    <div style=\"margin-bottom: 16px\">\n      <button mat-raised-button color=\"secondary\" (click)=\"toggle1Let()\">\n        Open Manual test for Let in Alpha 1\n      </button>\n    </div>\n    <rxa-alpha1\n      *ngIf=\"show1LetAutoTest\"\n      [auto]=\"true\"\n      [type]=\"'rxLet'\"\n    ></rxa-alpha1>\n    <rxa-alpha1 *ngIf=\"show1Let\" [auto]=\"false\" [type]=\"'rxLet'\"></rxa-alpha1>\n  </div>\n</div>\n","import { AfterViewInit, Component, Input } from '@angular/core';\nimport { tap, take, finalize } from 'rxjs/operators';\nimport { BehaviorSubject, Subject, timer } from 'rxjs';\nimport { environment } from '../../../../../environments/environment';\n\n@Component({\n  selector: 'rxa-alpha1',\n  templateUrl: './alpha-1-toggle.component.html',\n  changeDetection: environment.changeDetection,\n})\nexport class Alpha1ToggleComponent implements AfterViewInit {\n  private letEmitted = false;\n  @Input() type: 'rxLet' | 'push';\n  @Input() auto: boolean;\n\n  pushLoading$ = new BehaviorSubject<boolean>(true);\n  letLoading$ = new Subject<boolean>();\n  done$ = new BehaviorSubject<boolean>(false);\n\n  process$ = timer(800, 800);\n\n  constructor() {}\n\n  ngAfterViewInit() {\n    if (this.auto) {\n      this.process$\n        .pipe(\n          tap(() =>\n            this.type === 'push' ? this.togglePush() : this.toggleLet()\n          ),\n          take(10),\n          finalize(() => {\n            this.done$.next(true);\n          })\n        )\n        .subscribe();\n    }\n  }\n\n  toggleList() {\n    this.type === 'push' ? this.togglePush() : this.toggleLet();\n  }\n\n  togglePush() {\n    this.pushLoading$.next(!this.pushLoading$.getValue());\n  }\n\n  toggleLet() {\n    if (!this.letEmitted) {\n      this.letEmitted = true;\n      return this.letLoading$.next(true);\n    }\n\n    this.letLoading$ = new Subject();\n    this.letEmitted = false;\n  }\n}\n","<div class=\"col-sm-12 col-md-6\">\n  <ng-container *ngIf=\"auto\">\n    <p>List of 2000 elements will be toggled 10 times</p>\n  </ng-container>\n  <ng-container *ngIf=\"!auto\">\n    <button color=\"secondary\" (click)=\"toggleList()\">Reset</button>\n  </ng-container>\n\n  <ng-container *ngIf=\"type === 'push'\">\n    <p *ngIf=\"pushLoading$ | push; else pushContent\">Loading...</p>\n    <ng-template #pushContent>\n      <rxa-rendering-work [factor]=\"20\"></rxa-rendering-work>\n    </ng-template>\n  </ng-container>\n\n  <ng-container *ngIf=\"type === 'rxLet'\">\n    <ng-container *rxLet=\"letLoading$; let letLoading; suspense: suspenseTpl\">\n      <rxa-rendering-work [factor]=\"20\"></rxa-rendering-work>\n    </ng-container>\n    <ng-template #suspenseTpl> <p>Loading...</p> </ng-template>\n  </ng-container>\n\n  <p *ngIf=\"done$ | push\">Done</p>\n</div>\n","import { of, from, ReplaySubject, EMPTY, Subscription, Observable, asyncScheduler, animationFrameScheduler, asapScheduler, BehaviorSubject } from 'rxjs';\nimport { distinctUntilChanged, map, switchMap, filter, tap, withLatestFrom, catchError, observeOn } from 'rxjs/operators';\nimport { isObject } from 'util';\nimport { ɵmarkDirty, ChangeDetectorRef, Pipe, NgModule, TemplateRef, ViewContainerRef, Input, Directive, ElementRef } from '@angular/core';\nimport { __decorate, __metadata } from 'tslib';\n\nimport * as ɵngcc0 from '@angular/core';\nfunction toObservableValue(p) {\r\n    // @ts-ignore\r\n    return p == null ? of(p) : from(p);\r\n}\n\nfunction nameToStrategy(strategies) {\r\n    return (o$) => {\r\n        return o$.pipe(distinctUntilChanged(), map((strategy) => {\r\n            const s = strategies[strategy];\r\n            if (!!s) {\r\n                return s;\r\n            }\r\n            throw new Error(`Strategy ${strategy} does not exist.`);\r\n        }));\r\n    };\r\n}\n\n/**\r\n * RenderAware\r\n *\r\n * @description\r\n * This function returns an object that holds all the shared logic for the push pipe and the let directive\r\n * responsible for change detection\r\n * If you extend this class you need to implement how the update of the rendered value happens.\r\n * Also custom behaviour is something you need to implement in the extending class\r\n */\r\nfunction createRenderAware(cfg) {\r\n    const strategyName$ = new ReplaySubject(1);\r\n    const strategy$ = strategyName$.pipe(distinctUntilChanged(), switchMap(stringOrObservable => typeof stringOrObservable === 'string'\r\n        ? of(stringOrObservable)\r\n        : stringOrObservable), nameToStrategy(cfg.strategies));\r\n    const observablesFromTemplate$ = new ReplaySubject(1);\r\n    const valuesFromTemplate$ = observablesFromTemplate$.pipe(distinctUntilChanged());\r\n    let firstTemplateObservableChange = true;\r\n    const renderingEffect$ = valuesFromTemplate$.pipe(\r\n    // handle null | undefined assignment and new Observable reset\r\n    map(observable$ => {\r\n        if (observable$ === null) {\r\n            return of(null);\r\n        }\r\n        if (!firstTemplateObservableChange) {\r\n            cfg.resetObserver.next();\r\n            if (observable$ === undefined) {\r\n                return of(undefined);\r\n            }\r\n        }\r\n        firstTemplateObservableChange = false;\r\n        return observable$;\r\n    }), \r\n    // forward only observable values\r\n    filter(o$ => o$ !== undefined), switchMap(o$ => o$.pipe(distinctUntilChanged(), tap(cfg.updateObserver))), withLatestFrom(strategy$), tap(([v, strat]) => strat.scheduleCD()), catchError(e => {\r\n        console.error(e);\r\n        return EMPTY;\r\n    }));\r\n    return {\r\n        nextPotentialObservable(value) {\r\n            observablesFromTemplate$.next(value);\r\n        },\r\n        nextStrategy(nextConfig) {\r\n            strategyName$.next(nextConfig);\r\n        },\r\n        activeStrategy$: strategy$,\r\n        subscribe() {\r\n            return new Subscription()\r\n                .add(strategy$.subscribe())\r\n                .add(renderingEffect$.subscribe());\r\n        }\r\n    };\r\n}\n\n/**\r\n * @description\r\n *\r\n * A fallback for the new `globalThis` reference.\r\n *\r\n *  It should be used to replace `window` due to different environments in:\r\n *  - SSR (Server Side Rendering)\r\n *  - Tests\r\n *  - Browser\r\n *\r\n *  @return {globalThis} - A reference to globalThis. `window` in the Browser.\r\n */\r\nfunction getGlobalThis() {\r\n    return (globalThis || self || window);\r\n}\n\n/*\r\n * createPropertiesWeakMap\r\n *\r\n * @param getDefaults: (o: O) => P\r\n * Example:\r\n *\r\n * export interface Properties {\r\n *   isCoalescing: boolean;\r\n * }\r\n *\r\n * const obj: object = {\r\n *   foo: 'bar',\r\n *   isCoalescing: 'weakMap version'\r\n * };\r\n *\r\n * const getDefaults = (ctx: object): Properties => ({isCoalescing: false});\r\n * const propsMap = createPropertiesWeakMap<object, Properties>(getDefaults);\r\n *\r\n * console.log('obj before:', obj);\r\n * // {foo: \"bar\", isCoalescing: \"weakMap version\"}\r\n * console.log('props before:', propsMap.getProps(obj));\r\n * // {isCoalescing: \"weakMap version\"}\r\n *\r\n * propsMap.setProps(obj, {isCoalescing: true});\r\n * console.log('obj after:', obj);\r\n * // {foo: \"bar\", isCoalescing: \"weakMap version\"}\r\n * console.log('props after:', propsMap.getProps(obj));\r\n * // {isCoalescing: \"true\"}\r\n * */\r\nfunction createPropertiesWeakMap(getDefaults) {\r\n    const propertyMap = new WeakMap();\r\n    return {\r\n        getProps: getProperties,\r\n        setProps: setProperties\r\n    };\r\n    function getProperties(ctx) {\r\n        const defaults = getDefaults(ctx);\r\n        const propertiesPresent = propertyMap.get(ctx);\r\n        let properties;\r\n        if (propertiesPresent !== undefined) {\r\n            properties = propertiesPresent;\r\n        }\r\n        else {\r\n            properties = {};\r\n            Object.entries(defaults).forEach(([prop, value]) => {\r\n                properties[prop] = hasKey(ctx, prop) ? ctx[prop] : value;\r\n            });\r\n            propertyMap.set(ctx, properties);\r\n        }\r\n        return properties;\r\n    }\r\n    function setProperties(ctx, props) {\r\n        const properties = getProperties(ctx);\r\n        Object.entries(props).forEach(([prop, value]) => {\r\n            properties[prop] = value;\r\n        });\r\n        propertyMap.set(ctx, properties);\r\n        return properties;\r\n    }\r\n    function hasKey(ctx, property) {\r\n        return ctx[property] != null;\r\n    }\r\n}\n\n/**\r\n * envZonePatched\r\n *\r\n * @description\r\n *\r\n * This function checks the window object `zone.js` was instantiated.\r\n * If so, the `window` object maintains a property named `Zone`.\r\n *\r\n * Here how Angular checks it: https://github.com/angular/angular/blob/master/packages/core/src/zone/ng_zone.ts#L123\r\n *\r\n * @return {boolean} - true if `zone.js` patched global APIs.\r\n *\r\n */\r\nfunction envZonePatched() {\r\n    return getGlobalThis().Zone !== undefined;\r\n}\r\n/**\r\n * apiZonePatched\r\n *\r\n * @description\r\n *\r\n * This function checks if a specific Browser API is patched by `zone.js`.\r\n *\r\n * @param name {string} - The name of the API to check.\r\n * @return {boolean} - true if `zone.js` patched the API in question.\r\n *\r\n */\r\nfunction apiZonePatched(name) {\r\n    // if symbol is present, zone patched the API\r\n    return getGlobalThis()['__zone_symbol__' + name] !== undefined;\r\n}\r\nconst zoneDetectionCache = new WeakMap();\r\n/**\r\n * isNgZone\r\n *\r\n * @description\r\n *\r\n * This function takes an instance of a class which implements the NgZone interface and checks if\r\n * its `runOutsideAngular()` function calls `apply()` on the function passed as parameter. This\r\n * means the Angular application that instantiated this service assumes it runs in a ZoneLess\r\n * environment, and therefore it's change detection will not be triggered by zone related logic.\r\n *\r\n * However, keep in mind this does not mean `zone.js` is not present.\r\n * The environment could still run in ZoneFull mode even if Angular turned it off.\r\n * Consider the situation of a Angular element configured for ZoneLess\r\n * environments is used in an Angular application relining on the zone mechanism.\r\n *\r\n * @param instance {Class Instance} - The instance to check for constructor name of `NgZone`.\r\n * @return {boolean} - true if instance is of type `NgZone`.\r\n *\r\n */\r\nfunction isNgZone(instance) {\r\n    const cachedValue = zoneDetectionCache.get(instance);\r\n    if (cachedValue !== undefined) {\r\n        return cachedValue;\r\n    }\r\n    let calledApply = false;\r\n    function fn() { }\r\n    fn.apply = () => (calledApply = true);\r\n    instance.runOutsideAngular(fn);\r\n    zoneDetectionCache.set(instance, calledApply);\r\n    return calledApply;\r\n}\r\n/**\r\n * isNoopNgZone\r\n *\r\n *@description\r\n *\r\n * This function takes any instance of a class and checks\r\n * if the constructor name is equal to `NoopNgZone`.\r\n *\r\n * For more detailed information read the description of [isNgZone](#isngzone).\r\n *\r\n * @param instance {Class Instance} - The instance to check for constructor name of `NoopNgZone`.\r\n * @return {boolean} - true if instance is of type `NoopNgZone`.\r\n *\r\n */\r\nfunction isNoopNgZone(instance) {\r\n    return !isNgZone(instance);\r\n}\n\n/** A shared promise instance to cause a delay of one microtask */\r\nlet resolvedPromise = null;\r\nfunction getUnpatchedResolvedPromise() {\r\n    resolvedPromise =\r\n        resolvedPromise ||\r\n            (apiZonePatched('Promise')\r\n                ? getGlobalThis().__zone_symbol__Promise.resolve()\r\n                : Promise.resolve());\r\n    return resolvedPromise;\r\n}\n\n/**\r\n * envRunsIvy\r\n *\r\n * @description\r\n * Determines the used view engine of an Angular project is Ivy or not.\r\n * The check is done based on following table:\r\n * | render       | ViewEngine | ViewEngine | Ivy         | Ivy         |\r\n * | ------------ | ---------- | ---------- | ----------- | ----------- |\r\n * | **mode**     | prod       | dev        | prod        | dev         |\r\n * | **ng**       | present    | present    | `undefined` | present     |\r\n * | **ng.probe** | present    | present    | `undefined` | `undefined` |\r\n *\r\n *  So for Ivy we need to make sure that ng is undefined or,\r\n *  in case of dev environment, ng.probe is undefined.\r\n *\r\n * @return {boolean} - true if the used view engine is Ivy.\r\n *\r\n */\r\nfunction isViewEngineIvy() {\r\n    const ng = getGlobalThis().ng;\r\n    // Is the global ng object is unavailable?\r\n    // ng === undefined in Ivy production mode\r\n    // View Engine has the ng object both in development mode and production mode.\r\n    return (ng === undefined ||\r\n        // in case we are in dev mode in ivy\r\n        // `probe` property is available on ng object we use View Engine.\r\n        ng.probe === undefined);\r\n}\n\n/**\r\n * getZoneUnPatchedApi\r\n *\r\n * @description\r\n *\r\n * This function returns the zone un-patched API for the a specific Browser API.\r\n * If no element is passed the window is used instead\r\n *\r\n * @param name {string} - The name of the API to check.\r\n * @param elem {any} - The elem to get un-patched API from.\r\n * @return {Function} - The zone un-patched API in question.\r\n *\r\n */\r\nfunction getZoneUnPatchedApi(name, elem) {\r\n    elem = elem || getGlobalThis();\r\n    return apiZonePatched(name) ? elem['__zone_symbol__' + name] : elem[name];\r\n}\r\n/**\r\n *\r\n * @description\r\n *\r\n * This function takes an elem and event and re-applies the listeners from the passed event to the\r\n * passed element with the zone un-patched version of it.\r\n *\r\n * @param elem {HTMLElement} - The elem to re-apply the listeners to.\r\n * @param event {string} - The name of the event from which to re-apply the listeners.\r\n *\r\n * @returns void\r\n */\r\nfunction unpatchEventListener(elem, event) {\r\n    const eventListeners = elem.eventListeners(event);\r\n    // Return if no event listeners are present\r\n    if (!eventListeners) {\r\n        return;\r\n    }\r\n    const addEventListener = getZoneUnPatchedApi('addEventListener', elem).bind(elem);\r\n    eventListeners.forEach(listener => {\r\n        // Remove and reapply listeners with patched API\r\n        elem.removeEventListener(event, listener);\r\n        // Reapply listeners with un-patched API\r\n        addEventListener(event, listener);\r\n    });\r\n}\n\nconst ɵ0 = ctx => ({\r\n    numCoalescingSubscribers: 0\r\n});\r\nconst coalescingContextPropertiesMap = createPropertiesWeakMap(ɵ0);\r\nfunction createCoalesceManager(scope = {}) {\r\n    return {\r\n        remove: removeSubscriber,\r\n        add: addSubscription,\r\n        isCoalescing\r\n    };\r\n    // Increments the number of subscriptions in a scope e.g. a class instance\r\n    function removeSubscriber() {\r\n        const numCoalescingSubscribers = coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers -\r\n            1;\r\n        coalescingContextPropertiesMap.setProps(scope, {\r\n            numCoalescingSubscribers\r\n        });\r\n    }\r\n    // Decrements the number of subscriptions in a scope e.g. a class instance\r\n    function addSubscription() {\r\n        const numCoalescingSubscribers = coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers +\r\n            1;\r\n        coalescingContextPropertiesMap.setProps(scope, {\r\n            numCoalescingSubscribers\r\n        });\r\n    }\r\n    // Checks if anybody else is already coalescing atm\r\n    function isCoalescing() {\r\n        return (coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers >\r\n            0);\r\n    }\r\n}\n\n/**\r\n * @description\r\n * Limits the number of synchronous emitted a value from the source Observable to\r\n * one emitted value per\r\n *   [`AnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame), then repeats\r\n *   this process for every tick of the browsers event loop.\r\n *\r\n * The coalesce operator is based on the [throttle](https://rxjs-dev.firebaseapp.com/api/operators/throttle) operator.\r\n * In addition to that is provides emitted values for the trailing end only, as well as maintaining a context to scope\r\n *   coalescing.\r\n *\r\n * @param {function(value: T): SubscribableOrPromise} durationSelector - A function\r\n * that receives a value from the source Observable, for computing the silencing\r\n * duration for each source value, returned as an Observable or a Promise.\r\n * It defaults to `requestAnimationFrame` as durationSelector.\r\n * @param {Object} config - A configuration object to define `leading` and `trailing` behavior and the context object.\r\n * Defaults to `{ leading: false, trailing: true }`. The default scoping is per subscriber.\r\n * @return {Observable<T>} An Observable that performs the coalesce operation to\r\n * limit the rate of emissions from the source.\r\n *\r\n * @usageNotes\r\n * Emit clicks at a rate of at most one click per second\r\n * ```ts\r\n * import { fromEvent, animationFrames } from 'rxjs';\r\n * import { coalesce } from 'ngRx/component';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(coalesce(ev => animationFrames));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n */\r\nfunction coalesceWith(durationSelector, scope) {\r\n    const _scope = scope || {};\r\n    return source => {\r\n        const o$ = new Observable(observer => {\r\n            const rootSubscription = new Subscription();\r\n            rootSubscription.add(source.subscribe(createInnerObserver(observer, rootSubscription)));\r\n            return rootSubscription;\r\n        });\r\n        return o$;\r\n        function createInnerObserver(outerObserver, rootSubscription) {\r\n            let actionSubscription;\r\n            let latestValue;\r\n            const coa = createCoalesceManager(_scope);\r\n            const tryEmitLatestValue = () => {\r\n                coa.remove();\r\n                if (!coa.isCoalescing()) {\r\n                    outerObserver.next(latestValue);\r\n                }\r\n            };\r\n            return {\r\n                complete: () => {\r\n                    if (actionSubscription) {\r\n                        tryEmitLatestValue();\r\n                    }\r\n                    outerObserver.complete();\r\n                },\r\n                error: error => outerObserver.error(error),\r\n                next: value => {\r\n                    latestValue = value;\r\n                    if (!actionSubscription) {\r\n                        coa.add();\r\n                        actionSubscription = durationSelector.subscribe({\r\n                            next: () => {\r\n                                tryEmitLatestValue();\r\n                                actionSubscription = undefined;\r\n                            },\r\n                            complete: () => {\r\n                                if (actionSubscription) {\r\n                                    tryEmitLatestValue();\r\n                                    actionSubscription = undefined;\r\n                                }\r\n                            }\r\n                        });\r\n                        rootSubscription.add(actionSubscription);\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    };\r\n}\n\nfunction renderChange(strategy) {\r\n    return (s) => {\r\n        return s.pipe(strategy.behavior, tap(v => strategy.renderMethod()));\r\n    };\r\n}\n\nconst unpatchedAsapScheduler = {\r\n    now() {\r\n        return 0;\r\n    },\r\n    schedule(work, options, state) {\r\n        return from(getUnpatchedResolvedPromise()).subscribe(() => work(state));\r\n    }\r\n};\n\n/**\r\n *\r\n * Implementation based on rxjs-etc => IdleScheduler\r\n *\r\n */\r\nvar PostTaskSchedulerPriority;\r\n(function (PostTaskSchedulerPriority) {\r\n    PostTaskSchedulerPriority[\"background\"] = \"background\";\r\n    PostTaskSchedulerPriority[\"userBlocking\"] = \"user-blocking\";\r\n    PostTaskSchedulerPriority[\"userVisible\"] = \"user-visible\";\r\n})(PostTaskSchedulerPriority || (PostTaskSchedulerPriority = {}));\r\nconst postTaskScheduler = typeof window !== 'undefined'\r\n    ? window.scheduler || {\r\n        postTask(options) {\r\n            const start = Date.now();\r\n            return new Promise(resolve => {\r\n                setTimeout(function () {\r\n                    console.error('postTask not implemented. Use setTimeout as fallback');\r\n                    resolve();\r\n                }, 1);\r\n            });\r\n        }\r\n    }\r\n    : () => { };\r\nclass PostTaskAction extends Subscription {\r\n    constructor(work) {\r\n        super();\r\n        this.work = work;\r\n    }\r\n    schedule(state, delay) {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n        return this._scheduler.schedule(this.work, delay, state);\r\n    }\r\n}\r\nfunction getPostTaskScheduler(priority) {\r\n    return {\r\n        now() {\r\n            return asyncScheduler.now();\r\n        },\r\n        schedule(work, options = {}, state) {\r\n            if (isObject(options) && options.delay) {\r\n                return asyncScheduler.schedule(work, options.delay, state);\r\n            }\r\n            options = Object.assign(Object.assign({}, options), { priority });\r\n            const action = new PostTaskAction(work);\r\n            // weired hack\r\n            action._scheduler = this;\r\n            const promise = postTaskScheduler\r\n                .postTask(() => { }, options)\r\n                .then(() => {\r\n                try {\r\n                    work.call(action, state);\r\n                }\r\n                catch (error) {\r\n                    action.unsubscribe();\r\n                    throw error;\r\n                }\r\n            });\r\n            action.add(() => {\r\n                throw new Error('not implemented');\r\n            });\r\n            return action;\r\n        }\r\n    };\r\n}\n\nconst cancelIdleCallback = typeof window !== 'undefined'\r\n    ? window.cancelIdleCallback ||\r\n        function (idleId) {\r\n            console.warn('Fake cancelIdleCallback used');\r\n            clearTimeout(idleId);\r\n        }\r\n    : () => { };\r\nconst requestIdleCallback = typeof window !== 'undefined'\r\n    ? window.requestIdleCallback ||\r\n        function (cb) {\r\n            console.warn('Fake requestIdleCallback used');\r\n            const start = Date.now();\r\n            return setTimeout(function () {\r\n                cb({\r\n                    didTimeout: false,\r\n                    timeRemaining: function () {\r\n                        return Math.max(0, 50 - (Date.now() - start));\r\n                    }\r\n                });\r\n            }, 1);\r\n        }\r\n    : () => { };\r\nclass IdleAction extends Subscription {\r\n    constructor(work) {\r\n        super();\r\n        this.work = work;\r\n    }\r\n    schedule(state, delay) {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n        return idleScheduler.schedule(this.work, delay, state);\r\n    }\r\n}\r\nconst idleScheduler = {\r\n    now() {\r\n        return asyncScheduler.now();\r\n    },\r\n    schedule(work, delay, state) {\r\n        if (delay) {\r\n            return asyncScheduler.schedule(work, delay, state);\r\n        }\r\n        const action = new IdleAction(work);\r\n        const id = requestIdleCallback(() => {\r\n            try {\r\n                work.call(action, state);\r\n            }\r\n            catch (error) {\r\n                action.unsubscribe();\r\n                throw error;\r\n            }\r\n        });\r\n        action.add(() => cancelIdleCallback(id));\r\n        return action;\r\n    }\r\n};\n\nconst ɵ0$1 = subscriber => {\r\n    let i = 0;\r\n    const id = getZoneUnPatchedApi('requestAnimationFrame')(() => {\r\n        subscriber.next(++i);\r\n    });\r\n    return () => {\r\n        getZoneUnPatchedApi('cancelAnimationFrame')(id);\r\n    };\r\n};\r\nconst animationFrameTick = new Observable(ɵ0$1);\r\nconst unpatchedAnimationFrameScheduler = {\r\n    now() {\r\n        return 0;\r\n    },\r\n    schedule(work, options, state) {\r\n        return animationFrameTick.subscribe(() => work(state));\r\n    }\r\n};\n\nvar SchedulingPriority;\r\n(function (SchedulingPriority) {\r\n    SchedulingPriority[\"animationFrame\"] = \"animationFrame\";\r\n    SchedulingPriority[\"Promise\"] = \"Promise\";\r\n    SchedulingPriority[\"idleCallback\"] = \"idleCallback\";\r\n    SchedulingPriority[\"userBlocking\"] = \"userBlocking\";\r\n    SchedulingPriority[\"userVisible\"] = \"userVisible\";\r\n    SchedulingPriority[\"background\"] = \"background\";\r\n    SchedulingPriority[\"setInterval\"] = \"setInterval\";\r\n})(SchedulingPriority || (SchedulingPriority = {}));\n\nconst prioritySchedulerMap = {\r\n    animationFrame: animationFrameScheduler,\r\n    Promise: asapScheduler,\r\n    setInterval: asyncScheduler,\r\n    idleCallback: idleScheduler,\r\n    userBlocking: getPostTaskScheduler(PostTaskSchedulerPriority.userBlocking),\r\n    userVisible: getPostTaskScheduler(PostTaskSchedulerPriority.userVisible),\r\n    background: getPostTaskScheduler(PostTaskSchedulerPriority.background)\r\n};\r\nfunction getScheduler(priority) {\r\n    if (!prioritySchedulerMap.hasOwnProperty(priority)) {\r\n        throw new Error(`priority ${priority} is not present in prioritiesMap`);\r\n    }\r\n    return prioritySchedulerMap[priority];\r\n}\n\nfunction staticCoalesce(work, durationSelector, scope = {}) {\r\n    const coalescingManager = createCoalesceManager(scope);\r\n    if (!coalescingManager.isCoalescing()) {\r\n        coalescingManager.add();\r\n        durationSelector.subscribe(() => {\r\n            tryExecuteWork();\r\n        });\r\n    }\r\n    // =====\r\n    function tryExecuteWork() {\r\n        coalescingManager.remove();\r\n        if (!coalescingManager.isCoalescing()) {\r\n            return work();\r\n        }\r\n    }\r\n}\n\nfunction schedule(work, priority) {\r\n    return getScheduler(priority).schedule(() => work());\r\n}\n\nfunction coalesceAndSchedule(work, priority, scope = {}) {\r\n    const durationSelector = from(getUnpatchedResolvedPromise());\r\n    const scheduledWork = () => schedule(work, priority);\r\n    staticCoalesce(scheduledWork, durationSelector, scope);\r\n}\n\n/**\r\n * Noop Strategy\r\n *\r\n * This strategy is does nothing. It serves for debugging only\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `noop`      | ❌/❌         | no rendering        | ❌               |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nfunction createNoopStrategy() {\r\n    return {\r\n        name: 'noop',\r\n        renderMethod: () => { },\r\n        behavior: o => o,\r\n        scheduleCD: () => { }\r\n    };\r\n}\n\n/**\r\n * Native Strategy\r\n * @description\r\n *\r\n * This strategy mirrors Angular's built-in `async` pipe.\r\n * This means for every emitted value `ChangeDetectorRef#markForCheck` is called.\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `native`    | ❌/❌         | mFC / mFC           | ❌               |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nfunction createNativeStrategy(config) {\r\n    return {\r\n        name: 'native',\r\n        renderMethod: config.cdRef.markForCheck,\r\n        behavior: o => o,\r\n        scheduleCD: () => {\r\n            config.cdRef.markForCheck();\r\n        }\r\n    };\r\n}\n\n/**\r\n * Strategies\r\n *\r\n * - VE/I - Options for ViewEngine / Ivy\r\n * - mFC - `cdRef.markForCheck`\r\n * - dC - `cdRef.detectChanges`\r\n * - ɵMD - `ɵmarkDirty`\r\n * - ɵDC - `ɵdetectChanges`\r\n * - LV  - `LView`\r\n * - C - `Component`\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------------- | ---------------- |\r\n * | `local`    | ✔/✔ ️        | dC / ɵDC            | ✔ ️ + C/ LV     |\r\n * | `detach`   | ❌/✔ ️       | mFC  / ɵMD          | ❌               |\r\n * | `postTask` | ❌/✔ ️       | mFC  / ɵMD          | ❌               |\r\n * | `idleCallback` | ❌/✔ ️   | mFC  / ɵMD          | ❌               |\r\n *\r\n */\r\nfunction getLocalStrategies(config) {\r\n    return {\r\n        local: createLocalStrategy(config),\r\n        localCoalesce: createLocalCoalesceStrategy(config),\r\n        localCoalesceAndSchedule: createLocalCoalesceAndScheduleStrategy(config),\r\n        localNative: createLocalNativeStrategy(config),\r\n        detach: createDetachStrategy(config),\r\n        userVisible: createUserVisibleStrategy(config),\r\n        userBlocking: createUserBlockingStrategy(config),\r\n        background: createBackgroundStrategy(config),\r\n        idleCallback: createIdleCallbackStrategy(config)\r\n    };\r\n}\r\nfunction createLocalNativeStrategy(config) {\r\n    const renderMethod = () => {\r\n        config.cdRef.detectChanges();\r\n    };\r\n    const behavior = o => o.pipe();\r\n    const scheduleCD = () => renderMethod();\r\n    return {\r\n        name: 'localNative',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\r\n/**\r\n *  Local Strategy\r\n *\r\n * This strategy is rendering the actual component and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * As detectChanges has no coalescing of render calls\r\n * like `ChangeDetectorRef#markForCheck` or `ɵmarkDirty` has, so we have to apply our own coalescing, 'scoped' on\r\n * component level.\r\n *\r\n * Coalescing, in this very manner,\r\n * means **collecting all events** in the same\r\n * [EventLoop](https://developer.mozilla.org/de/docs/Web/JavaScript/EventLoop) tick, that would cause a re-render and\r\n * execute **re-rendering only once**.\r\n *\r\n * 'Scoped' coalescing, in addition, means **grouping the collected events by** a specific context.\r\n * E. g. the **component** from which the re-rendering was initiated.\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `ɵlocal`    | ✔️/✔️    | dC / dC             | ✔️ + C         |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nfunction createLocalStrategy(config) {\r\n    const durationSelector = from(getUnpatchedResolvedPromise());\r\n    const scope = config.cdRef.context;\r\n    const priority = SchedulingPriority.animationFrame;\r\n    const scheduler = getScheduler(priority);\r\n    const renderMethod = () => {\r\n        config.cdRef.detectChanges();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n    const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n    return {\r\n        name: 'local',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\r\nfunction createLocalCoalesceStrategy(config) {\r\n    const durationSelector = from(getUnpatchedResolvedPromise());\r\n    const scope = config.cdRef.context;\r\n    const priority = SchedulingPriority.animationFrame;\r\n    const scheduler = getScheduler(priority);\r\n    const renderMethod = () => {\r\n        config.cdRef.detectChanges();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n    const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n    return {\r\n        name: 'localCoalesce',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\r\nfunction createLocalCoalesceAndScheduleStrategy(config) {\r\n    const durationSelector = from(getUnpatchedResolvedPromise());\r\n    const scope = config.cdRef.context;\r\n    const priority = SchedulingPriority.animationFrame;\r\n    const scheduler = getScheduler(priority);\r\n    const renderMethod = () => {\r\n        config.cdRef.detectChanges();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n    const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n    return {\r\n        name: 'localCoalesceAndSchedule',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\r\n/**\r\n *  Detach Strategy\r\n *\r\n * This strategy is rendering the actual component and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * As detectChanges has no coalescing of render calls\r\n * like `ChangeDetectorRef#markForCheck` or `ɵmarkDirty` has, so we have to apply our own coalescing, 'scoped' on\r\n * component level.\r\n *\r\n * Coalescing, in this very manner,\r\n * means **collecting all events** in the same\r\n * [EventLoop](https://developer.mozilla.org/de/docs/Web/JavaScript/EventLoop) tick, that would cause a re-render and\r\n * execute **re-rendering only once**.\r\n *\r\n * 'Scoped' coalescing, in addition, means **grouping the collected events by** a specific context.\r\n * E. g. the **component** from which the re-rendering was initiated.\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `ɵdetach`     | ✔️/✔️          | dC / ɵDC            | ✔️ + C/ LV       |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nfunction createDetachStrategy(config) {\r\n    const durationSelector = from(getUnpatchedResolvedPromise());\r\n    const scope = config.cdRef.context;\r\n    const priority = SchedulingPriority.animationFrame;\r\n    const scheduler = getScheduler(priority);\r\n    const renderMethod = () => {\r\n        config.cdRef.reattach();\r\n        config.cdRef.detectChanges();\r\n        config.cdRef.detach();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n    const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n    return {\r\n        name: 'detach',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\r\n/**\r\n *  PostTask - Priority UserVisible Strategy\r\n *\r\n */\r\nfunction createUserVisibleStrategy(config) {\r\n    const durationSelector = new Observable(subscriber => {\r\n        from(postTaskScheduler.postTask(() => void 0, {\r\n            priority: PostTaskSchedulerPriority.userVisible,\r\n            delay: 0\r\n        })).subscribe(subscriber);\r\n    });\r\n    const scope = config.cdRef.context;\r\n    const priority = SchedulingPriority.background;\r\n    const scheduler = getScheduler(priority);\r\n    const renderMethod = () => {\r\n        config.cdRef.detectChanges();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n    const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n    return {\r\n        name: 'userVisible',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\r\n/**\r\n *  PostTask - Priority UserBlocking Strategy\r\n *\r\n */\r\nfunction createUserBlockingStrategy(config) {\r\n    const durationSelector = new Observable(subscriber => {\r\n        from(postTaskScheduler.postTask(() => void 0, {\r\n            priority: PostTaskSchedulerPriority.userVisible,\r\n            delay: 0\r\n        })).subscribe(subscriber);\r\n    });\r\n    const scope = config.cdRef.context;\r\n    const priority = SchedulingPriority.background;\r\n    const scheduler = getScheduler(priority);\r\n    const renderMethod = () => {\r\n        config.cdRef.detectChanges();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n    const scheduleCD = () => {\r\n        staticCoalesce(renderMethod, durationSelector, scope);\r\n        // coalesceAndSchedule(renderMethod, priority, scope);\r\n    };\r\n    return {\r\n        name: 'userBlocking',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\r\n/**\r\n *  PostTask - Priority Background Strategy\r\n *\r\n */\r\nfunction createBackgroundStrategy(config) {\r\n    const durationSelector = new Observable(subscriber => {\r\n        from(postTaskScheduler.postTask(() => void 0, {\r\n            priority: PostTaskSchedulerPriority.userVisible,\r\n            delay: 0\r\n        })).subscribe(subscriber);\r\n    });\r\n    const scope = config.cdRef.context;\r\n    const priority = SchedulingPriority.background;\r\n    const scheduler = getScheduler(priority);\r\n    const renderMethod = () => {\r\n        config.cdRef.detectChanges();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n    const scheduleCD = () => {\r\n        staticCoalesce(renderMethod, durationSelector, scope);\r\n        // coalesceAndSchedule(renderMethod, priority, scope);\r\n    };\r\n    return {\r\n        name: 'background',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\r\n/**\r\n *  IdleCallback Strategy\r\n *\r\n * This strategy is rendering the actual component and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * As detectChanges is used the coalescing described in `ɵlocal` is implemented here.\r\n *\r\n * 'Scoped' coalescing, in addition, means **grouping the collected events by** a specific context.\r\n * E. g. the **component** from which the re-rendering was initiated.\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `ɵdetach`     | ✔️/✔️          | dC / ɵDC            | ✔️ + C/ LV       |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nfunction createIdleCallbackStrategy(config) {\r\n    const durationSelector = from(getUnpatchedResolvedPromise());\r\n    const scope = config.cdRef.context;\r\n    const priority = SchedulingPriority.idleCallback;\r\n    const scheduler = getScheduler(priority);\r\n    const renderMethod = () => {\r\n        config.cdRef.detectChanges();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(durationSelector, scope), observeOn(scheduler));\r\n    const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, scope);\r\n    return {\r\n        name: 'idleCallback',\r\n        renderMethod,\r\n        behavior,\r\n        scheduleCD\r\n    };\r\n}\n\nfunction getGlobalStrategies(config) {\r\n    return {\r\n        global: createGlobalStrategy(config)\r\n    };\r\n}\r\n/**\r\n * Strategies\r\n *\r\n * - VE/I - Options for ViewEngine / Ivy\r\n * - mFC - `cdRef.markForCheck`\r\n * - dC - `cdRef.detectChanges`\r\n * - ɵMD - `ɵmarkDirty`\r\n * - ɵDC - `ɵdetectChanges`\r\n * - LV  - `LView`\r\n * - C - `Component`\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------------- | ---------------- |\r\n * | `global`   | ❌/✔ ️        | mFC  / ɵMD          | ❌               |\r\n *\r\n */\r\n/**\r\n *\r\n * Global Strategy\r\n *\r\n * This strategy is rendering the application root and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing       |\r\n * |-------------| --------------| ------------ ------ | ---------------- |\r\n * | `global`   | ❌/✔️       | mFC / ɵMD           | ❌                |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nfunction createGlobalStrategy(config) {\r\n    const renderMethod = () => ɵmarkDirty(config.cdRef.context);\r\n    return {\r\n        name: 'global',\r\n        renderMethod,\r\n        behavior: o => o,\r\n        scheduleCD: () => renderMethod()\r\n    };\r\n}\n\nconst DEFAULT_STRATEGY_NAME = 'local';\r\nfunction getStrategies(config) {\r\n    return Object.assign(Object.assign({ noop: createNoopStrategy(), native: createNativeStrategy(config) }, getGlobalStrategies(config)), getLocalStrategies(config));\r\n}\r\n/**\r\n * Strategies\r\n *\r\n * - VE/I - Options for ViewEngine / Ivy\r\n * - mFC - `cdRef.markForCheck`\r\n * - dC - `cdRef.detectChanges`\r\n * - ɵMD - `ɵmarkDirty`\r\n * - ɵDC - `ɵdetectChanges`\r\n * - LV  - `LView`\r\n * - C - `Component`\r\n *\r\n * | Name        | ZoneLess VE/I | Render Method VE/I  | Coalescing VE/I  |\r\n * |-------------| --------------| ------------------- | ---------------- |\r\n * | `noop`      | ❌/❌          | no rendering        | ❌               |\r\n * | `native`    | ❌/❌          | mFC / mFC           | ❌               |\r\n * | `global`    | ❌/✔ ️       | mFC  / ɵMD           | ❌               |\r\n * | `local`     | ✔/✔ ️        | dC / ɵDC            | ✔ ️ + C/ LV     |\r\n * | `ɵglobal`   | ❌/✔ ️       | mFC  / ɵMD          | ❌               |\r\n * | `ɵlocal`    | ✔/✔ ️       | dC / ɵDC             | ✔ ️ + C/ LV     |\r\n * | `ɵdetach`   | ❌/✔ ️       | mFC  / ɵMD          | ❌               |\r\n *\r\n */\n\n/**\r\n * @Pipe PushPipe\r\n *\r\n * @description\r\n *\r\n * The `push` pipe serves as a drop-in replacement for the `async` pipe.\r\n * It contains intelligent handling of change detection to enable us\r\n * running in zone-full as well as zone-less mode without any changes to the code.\r\n *\r\n * The current way of binding an observable to the view looks like that:\r\n *  ```html\r\n *  {{observable$ | async}}\r\n * <ng-container *ngIf=\"observable$ | async as o\">{{o}}</ng-container>\r\n * <component [value]=\"observable$ | async\"></component>\r\n * ```\r\n *\r\n * The problem is `async` pipe just marks the component and all its ancestors as dirty.\r\n * It needs zone.js microtask queue to exhaust until `ApplicationRef.tick` is called to render all dirty marked\r\n *     components.\r\n *\r\n * Heavy dynamic and interactive UIs suffer from zones change detection a lot and can\r\n * lean to bad performance or even unusable applications, but the `async` pipe does not work in zone-less mode.\r\n *\r\n * `push` pipe solves that problem.\r\n *\r\n * Included Features:\r\n *  - Take observables or promises, retrieve their values and render the value to the template\r\n *  - Handling null and undefined values in a clean unified/structured way\r\n *  - Triggers change-detection differently if `zone.js` is present or not (`detectChanges` or `markForCheck`)\r\n *  - Distinct same values in a row to increase performance\r\n *  - Coalescing of change detection calls to boost performance\r\n *\r\n * @usageNotes\r\n *\r\n * `push` pipe solves that problem. It can be used like shown here:\r\n * ```html\r\n * {{observable$ | push}}\r\n * <ng-container *ngIf=\"observable$ | push as o\">{{o}}</ng-container>\r\n * <component [value]=\"observable$ | push\"></component>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nlet PushPipe = class PushPipe {\r\n    constructor(cdRef) {\r\n        this.resetObserver = {\r\n            next: () => {\r\n                this.renderedValue = undefined;\r\n            }\r\n        };\r\n        this.updateObserver = {\r\n            next: (value) => (this.renderedValue = value)\r\n        };\r\n        this.RenderAware = createRenderAware({\r\n            strategies: getStrategies({ cdRef }),\r\n            updateObserver: this.updateObserver,\r\n            resetObserver: this.resetObserver\r\n        });\r\n        this.subscription = this.RenderAware.subscribe();\r\n    }\r\n    transform(potentialObservable, config) {\r\n        const strategy = config || DEFAULT_STRATEGY_NAME;\r\n        this.RenderAware.nextStrategy(strategy);\r\n        this.RenderAware.nextPotentialObservable(potentialObservable);\r\n        return this.renderedValue;\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscription.unsubscribe();\r\n    }\r\n};\nPushPipe.ɵfac = function PushPipe_Factory(t) { return new (t || PushPipe)(ɵngcc0.ɵɵinjectPipeChangeDetectorRef()); };\nPushPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: \"push\", type: PushPipe, pure: false });\r\nPushPipe.ctorParameters = () => [\r\n    { type: ChangeDetectorRef }\r\n];\r\nPushPipe = __decorate([ __metadata(\"design:paramtypes\", [ChangeDetectorRef])\r\n], PushPipe);\n\nconst DECLARATIONS = [PushPipe];\r\nlet PushModule = class PushModule {\r\n};\nPushModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PushModule });\nPushModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function PushModule_Factory(t) { return new (t || PushModule)(); }, imports: [[]] });\n\n/**\r\n * @Directive LetDirective\r\n *\r\n * @description\r\n *\r\n * The `*rxLet` directive serves a convenient way of binding observables to a view context (a dom element scope).\r\n * It also helps with several internal processing under the hood.\r\n *\r\n * The current way of binding an observable to the view looks like that:\r\n * ```html\r\n * <ng-container *ngIf=\"observableNumber$ as n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * <app-number-special [number]=\"n\">\r\n * </app-number-special>\r\n * </ng-container>\r\n *  ```\r\n *\r\n *  The problem is `*ngIf` is also interfering with rendering and in case of a `0` the component would be hidden\r\n *\r\n * Included Features:\r\n * - binding is always present. (`*ngIf=\"truthy$\"`)\r\n * - it takes away the multiple usages of the `async` or `push` pipe\r\n * - a unified/structured way of handling null and undefined\r\n * - triggers change-detection differently if `zone.js` is present or not (`ChangeDetectorRef.detectChanges` or\r\n *   `ChangeDetectorRef.markForCheck`)\r\n * - triggers change-detection differently if ViewEngine or Ivy is present (`ChangeDetectorRef.detectChanges` or\r\n *   `ɵdetectChanges`)\r\n * - distinct same values in a row (distinctUntilChanged operator),\r\n *\r\n * @usageNotes\r\n *\r\n * The `*rxLet` directive take over several things and makes it more convenient and save to work with streams in the\r\n *   template\r\n * `<ng-container *rxLet=\"observableNumber$ as c\"></ng-container>`\r\n *\r\n * ```html\r\n * <ng-container *rxLet=\"observableNumber$ as n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * </ng-container>\r\n *\r\n * <ng-container *rxLet=\"observableNumber$; let n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * </ng-container>\r\n * ```\r\n *\r\n * In addition to that it provides us information from the whole observable context.\r\n * We can track the observables:\r\n * - next value\r\n * - error value\r\n * - complete base-state\r\n *\r\n * ```html\r\n * <ng-container *rxLet=\"observableNumber$; let n; let e = $error, let c = $complete\">\r\n * <app-number [number]=\"n\"  *ngIf=\"!e && !c\">\r\n * </app-number>\r\n * <ng-container *ngIf=\"e\">\r\n * There is an error: {{e}}\r\n * </ng-container>\r\n * <ng-container *ngIf=\"c\">\r\n * Observable completed: {{c}}\r\n * </ng-container>\r\n * </ng-container>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nlet LetDirective = class LetDirective {\r\n    constructor(cdRef, templateRef, viewContainerRef) {\r\n        this.templateRef = templateRef;\r\n        this.viewContainerRef = viewContainerRef;\r\n        this.ViewContext = {\r\n            $implicit: undefined,\r\n            rxLet: undefined,\r\n            $error: false,\r\n            $complete: false\r\n        };\r\n        this.resetObserver = {\r\n            next: () => {\r\n                // if not initialized no need to set undefined\r\n                if (this.embeddedView) {\r\n                    this.ViewContext.$implicit = undefined;\r\n                    this.ViewContext.rxLet = undefined;\r\n                    this.ViewContext.$error = false;\r\n                    this.ViewContext.$complete = false;\r\n                }\r\n            }\r\n        };\r\n        this.updateObserver = {\r\n            next: (value) => {\r\n                // to have initial rendering lazy\r\n                if (!this.embeddedView) {\r\n                    this.createEmbeddedView();\r\n                }\r\n                this.ViewContext.$implicit = value;\r\n                this.ViewContext.rxLet = value;\r\n            },\r\n            error: (error) => {\r\n                // to have initial rendering lazy\r\n                if (!this.embeddedView) {\r\n                    this.createEmbeddedView();\r\n                }\r\n                this.ViewContext.$error = true;\r\n            },\r\n            complete: () => {\r\n                // to have initial rendering lazy\r\n                if (!this.embeddedView) {\r\n                    this.createEmbeddedView();\r\n                }\r\n                this.ViewContext.$complete = true;\r\n            }\r\n        };\r\n        this.strategies = getStrategies({ cdRef });\r\n        this.renderAware = createRenderAware({\r\n            strategies: this.strategies,\r\n            resetObserver: this.resetObserver,\r\n            updateObserver: this.updateObserver\r\n        });\r\n        this.renderAware.nextStrategy(DEFAULT_STRATEGY_NAME);\r\n    }\r\n    set rxLet(potentialObservable) {\r\n        this.renderAware.nextPotentialObservable(potentialObservable);\r\n    }\r\n    set strategy(strategy) {\r\n        this.renderAware.nextStrategy(strategy || DEFAULT_STRATEGY_NAME);\r\n    }\r\n    static ngTemplateContextGuard(dir, ctx) {\r\n        return true;\r\n    }\r\n    ngOnInit() {\r\n        this.subscription = this.renderAware.subscribe();\r\n    }\r\n    createEmbeddedView() {\r\n        this.embeddedView = this.viewContainerRef.createEmbeddedView(this.templateRef, this.ViewContext);\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscription.unsubscribe();\r\n        this.viewContainerRef.clear();\r\n    }\r\n};\nLetDirective.ɵfac = function LetDirective_Factory(t) { return new (t || LetDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };\nLetDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LetDirective, selectors: [[\"\", \"rxLet\", \"\"]], inputs: { rxLet: \"rxLet\", strategy: [\"rxLetStrategy\", \"strategy\"] } });\r\nLetDirective.ctorParameters = () => [\r\n    { type: ChangeDetectorRef },\r\n    { type: TemplateRef },\r\n    { type: ViewContainerRef }\r\n];\r\n__decorate([\r\n    Input(),\r\n    __metadata(\"design:type\", Object),\r\n    __metadata(\"design:paramtypes\", [Object])\r\n], LetDirective.prototype, \"rxLet\", null);\r\n__decorate([\r\n    Input('rxLetStrategy'),\r\n    __metadata(\"design:type\", Object),\r\n    __metadata(\"design:paramtypes\", [Object])\r\n], LetDirective.prototype, \"strategy\", null);\r\nLetDirective = __decorate([ __metadata(\"design:paramtypes\", [ChangeDetectorRef,\r\n        TemplateRef,\r\n        ViewContainerRef])\r\n], LetDirective);\n\nconst EXPORTED_DECLARATIONS = [LetDirective];\r\nlet LetModule = class LetModule {\r\n};\nLetModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LetModule });\nLetModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function LetModule_Factory(t) { return new (t || LetModule)(); } });\n\nconst zonePatchedEvents = [\r\n    'scroll',\r\n    'mousedown',\r\n    'mouseenter',\r\n    'mouseleave',\r\n    'mousemove',\r\n    'mouseout',\r\n    'mouseover',\r\n    'mouseup',\r\n    'load',\r\n    'pointerup',\r\n    'change',\r\n    'blur',\r\n    'focus',\r\n    'click',\r\n    'contextmenu',\r\n    'drag',\r\n    'dragend',\r\n    'dragenter',\r\n    'dragleave',\r\n    'dragover',\r\n    'dragstart',\r\n    'drop',\r\n    'input'\r\n];\n\n/**\r\n * @Directive UnpatchEventsDirective\r\n *\r\n * @description\r\n *\r\n * The `unpatch` directive helps in partially migrating to zone-less apps as well as getting rid\r\n * of unnecessary renderings through zones `addEventListener` patches.\r\n * It can be used on any element you apply event bindings.\r\n *\r\n * The current way of binding events to the DOM is to use output bindings:\r\n *  ```html\r\n * <button (click)=\"doStuff($event)\">click me</button>\r\n * ```\r\n *\r\n * The problem is that every event registered over `()` syntax, e.g. `(click)`\r\n * marks the component and all its ancestors as dirty and re-renders the whole component tree.\r\n * This is because zone.js patches the native browser API and whenever one of the patched APIs is used it re-renders.\r\n *\r\n * So even if your button is not related to a change that needs a re-render the app will re-render completely.\r\n * This leads to bad performance. This is especially helpful if you work with frequently fired events like 'mousemove'\r\n *\r\n * `unpatch` directive solves that problem.\r\n *\r\n * Included Features:\r\n *  - by default un-patch all registered listeners of the host it is applied on\r\n *  - un-patch only a specified set of registered event listeners\r\n *  - works zone independent (it directly checks the widow for patched APIs and un-patches them without the use of `runOutsideZone` which brings more performance)\r\n *  - Not interfering with any logic executed by the registered callback\r\n *\r\n * @usageNotes\r\n *\r\n * The `unpatch` directive can be used like shown here:\r\n * ```html\r\n * <button [unoatch] (click)=\"triggerSomeMethod($event)\">click me</button>\r\n * <button [unoatch]=\"['mousemove']\" (mousemove)=\"doStuff2($event)\" (click)=\"doStuff($event)\">click me</button>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\n// tslint:disable-next-line:directive-selector\r\nlet UnpatchEventsDirective = class UnpatchEventsDirective {\r\n    constructor(el) {\r\n        this.el = el;\r\n        this.subscription = new Subscription();\r\n        this.events$ = new BehaviorSubject(zonePatchedEvents);\r\n    }\r\n    set events(value) {\r\n        if (value && value.length > 0) {\r\n            this.events$.next(value);\r\n        }\r\n        else {\r\n            this.events$.next(zonePatchedEvents);\r\n        }\r\n    }\r\n    reapplyEventListenersZoneUnPatched(events) {\r\n        events.forEach(ev => {\r\n            unpatchEventListener(this.el.nativeElement, ev);\r\n        });\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscription.unsubscribe();\r\n    }\r\n    ngAfterViewInit() {\r\n        this.subscription = this.events$\r\n            .pipe(tap(eventList => this.reapplyEventListenersZoneUnPatched(eventList)))\r\n            .subscribe();\r\n    }\r\n};\nUnpatchEventsDirective.ɵfac = function UnpatchEventsDirective_Factory(t) { return new (t || UnpatchEventsDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\nUnpatchEventsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: UnpatchEventsDirective, selectors: [[\"\", \"unpatch\", \"\"]], inputs: { events: [\"unpatch\", \"events\"] } });\r\nUnpatchEventsDirective.ctorParameters = () => [\r\n    { type: ElementRef }\r\n];\r\n__decorate([\r\n    Input('unpatch'),\r\n    __metadata(\"design:type\", Array),\r\n    __metadata(\"design:paramtypes\", [Array])\r\n], UnpatchEventsDirective.prototype, \"events\", null);\r\nUnpatchEventsDirective = __decorate([ __metadata(\"design:paramtypes\", [ElementRef])\r\n], UnpatchEventsDirective);\n\nconst DECLARATIONS$1 = [UnpatchEventsDirective];\r\nlet UnpatchEventsModule = class UnpatchEventsModule {\r\n};\nUnpatchEventsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: UnpatchEventsModule });\nUnpatchEventsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function UnpatchEventsModule_Factory(t) { return new (t || UnpatchEventsModule)(); } });\n\nlet TemplateModule = class TemplateModule {\r\n};\nTemplateModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TemplateModule });\nTemplateModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TemplateModule_Factory(t) { return new (t || TemplateModule)(); }, imports: [LetModule, PushModule, UnpatchEventsModule] });\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PushPipe, [{\n        type: Pipe,\n        args: [{ name: 'push', pure: false }]\n    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PushModule, { declarations: [PushPipe], exports: [PushPipe] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PushModule, [{\n        type: NgModule,\n        args: [{\n                declarations: DECLARATIONS,\n                imports: [],\n                exports: DECLARATIONS\n            }]\n    }], null, null); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LetDirective, [{\n        type: Directive,\n        args: [{ selector: '[rxLet]' }]\n    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }]; }, { rxLet: [{\n            type: Input\n        }], strategy: [{\n            type: Input,\n            args: ['rxLetStrategy']\n        }] }); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LetModule, { declarations: [LetDirective], exports: [LetDirective] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LetModule, [{\n        type: NgModule,\n        args: [{\n                declarations: EXPORTED_DECLARATIONS,\n                exports: [EXPORTED_DECLARATIONS]\n            }]\n    }], null, null); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UnpatchEventsDirective, [{\n        type: Directive,\n        args: [{ selector: '[unpatch]' }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { events: [{\n            type: Input,\n            args: ['unpatch']\n        }] }); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(UnpatchEventsModule, { declarations: [UnpatchEventsDirective], exports: [UnpatchEventsDirective] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UnpatchEventsModule, [{\n        type: NgModule,\n        args: [{\n                declarations: DECLARATIONS$1,\n                exports: DECLARATIONS$1\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TemplateModule, { exports: [LetModule, PushModule, UnpatchEventsModule] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TemplateModule, [{\n        type: NgModule,\n        args: [{\n                exports: [LetModule, PushModule, UnpatchEventsModule]\n            }]\n    }], null, null); })();\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { LetDirective, LetModule, PushModule, PushPipe, SchedulingPriority, TemplateModule, UnpatchEventsDirective, UnpatchEventsModule, apiZonePatched, coalesceAndSchedule, coalesceWith, createCoalesceManager, createPropertiesWeakMap, createRenderAware, envZonePatched, getGlobalThis, getPostTaskScheduler, getScheduler, getStrategies, getUnpatchedResolvedPromise, getZoneUnPatchedApi, idleScheduler, isNgZone, isNoopNgZone, isViewEngineIvy, nameToStrategy, prioritySchedulerMap, renderChange, schedule, staticCoalesce, toObservableValue, unpatchEventListener, unpatchedAnimationFrameScheduler, unpatchedAsapScheduler, ɵ0, LetModule as ɵa, PushModule as ɵb, UnpatchEventsModule as ɵc };\n\n//# sourceMappingURL=rx-angular-template.js.map","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","import { AlphasCompareComponent } from './alphas-compare.component';\n\nexport const ROUTES = [\n  {\n    path: '',\n    redirectTo: 'alphas-compare',\n  },\n  {\n    path: 'list-toggle',\n    component: AlphasCompareComponent,\n  },\n];\n","import { AfterViewInit, Component, Input } from '@angular/core';\nimport { tap, take, finalize } from 'rxjs/operators';\nimport { BehaviorSubject, Subject, timer } from 'rxjs';\nimport { environment } from '../../../../../environments/environment';\n\n@Component({\n  selector: 'rxa-alpha0',\n  templateUrl: './alpha-0-toggle.component.html',\n  changeDetection: environment.changeDetection,\n})\nexport class Alpha0ToggleComponent implements AfterViewInit {\n  @Input() type: 'rxLet' | 'push';\n  @Input() auto: boolean;\n\n  pushLoading$ = new BehaviorSubject<boolean>(true);\n  letLoading$ = new BehaviorSubject<boolean>(true);\n  done$ = new BehaviorSubject<boolean>(false);\n\n  process$ = timer(800, 1000);\n\n  constructor() {}\n\n  ngAfterViewInit() {\n    if (this.auto) {\n      this.process$\n        .pipe(\n          tap(() =>\n            this.type === 'push' ? this.togglePush() : this.toggleLet()\n          ),\n          take(10),\n          finalize(() => {\n            this.done$.next(true);\n          })\n        )\n        .subscribe();\n    }\n  }\n\n  toggleList() {\n    this.type === 'push' ? this.togglePush() : this.toggleLet();\n  }\n\n  togglePush() {\n    this.pushLoading$.next(!this.pushLoading$.getValue());\n  }\n\n  toggleLet() {\n    this.letLoading$.next(!this.letLoading$.getValue());\n  }\n}\n","<div class=\"col-sm-12 col-md-6\">\n  <ng-container *ngIf=\"auto\">\n    <p>List of 2000 elements will be toggled 10 times</p>\n  </ng-container>\n  <ng-container *ngIf=\"!auto\">\n    <button [unpatch] color=\"secondary\" (click)=\"toggleList()\">Toggle</button>\n  </ng-container>\n\n  <ng-container *ngIf=\"type === 'push'\">\n    <p *ngIf=\"pushLoading$ | push; else pushContent\">Loading...</p>\n    <ng-template #pushContent>\n      <rxa-rendering-work [factor]=\"20\"></rxa-rendering-work>\n    </ng-template>\n  </ng-container>\n\n  <ng-container *ngIf=\"type === 'rxLet'\">\n    <ng-container *rxLet=\"letLoading$; let letLoading\">\n      <rxa-rendering-work\n        *ngIf=\"!letLoading\"\n        [factor]=\"20\"\n      ></rxa-rendering-work>\n      <p *ngIf=\"letLoading\">Loading...</p>\n    </ng-container>\n  </ng-container>\n  <p *ngIf=\"done$ | push\">Done</p>\n</div>\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { TemplateModule } from 'templateAlpha0';\nimport { Alpha0ToggleComponent } from './alpha-0-toggle.component';\nimport { RenderingWorkModule } from '../../../../shared/debug-helper/rendering-work/rendering-work.module';\n\n@NgModule({\n  declarations: [Alpha0ToggleComponent],\n  imports: [CommonModule, TemplateModule, RenderingWorkModule],\n  exports: [Alpha0ToggleComponent],\n})\nexport class Alpha0ToggleModule {}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { TemplateModule } from 'templateAlpha1';\nimport { Alpha1ToggleComponent } from './alpha-1-toggle.component';\nimport { RenderingWorkModule } from '../../../../shared/debug-helper/rendering-work/rendering-work.module';\n\n@NgModule({\n  declarations: [Alpha1ToggleComponent],\n  imports: [CommonModule, TemplateModule, RenderingWorkModule],\n  exports: [Alpha1ToggleComponent],\n})\nexport class Alpha1ToggleModule {}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","import { Observable, Subscription, ReplaySubject, of, EMPTY, from, BehaviorSubject, Subject } from 'rxjs';\nimport { tap, distinctUntilChanged, map, switchMap, filter, finalize, catchError, mergeAll, withLatestFrom } from 'rxjs/operators';\nimport { ɵmarkDirty, ɵdetectChanges, ChangeDetectorRef, Pipe, NgModule, TemplateRef, ViewContainerRef, Directive, Input, ElementRef, Optional } from '@angular/core';\n\n/**\r\n * @description\r\n *\r\n * A fallback for the new `globalThis` reference.\r\n *\r\n *  It should be used to replace `window` due to different environments in:\r\n *  - SSR (Server Side Rendering)\r\n *  - Tests\r\n *  - Browser\r\n *\r\n *  @return {globalThis} - A reference to globalThis. `window` in the Browser.\r\n */\r\nimport * as ɵngcc0 from '@angular/core';\nfunction getGlobalThis() {\r\n    return (window || self || globalThis);\r\n}\n\n/*\r\n * createPropertiesWeakMap\r\n *\r\n * @param getDefaults: (o: O) => P\r\n * Example:\r\n *\r\n * export interface Properties {\r\n *   isCoalescing: boolean;\r\n * }\r\n *\r\n * const obj: object = {\r\n *   foo: 'bar',\r\n *   isCoalescing: 'weakMap version'\r\n * };\r\n *\r\n * const getDefaults = (ctx: object): Properties => ({isCoalescing: false});\r\n * const propsMap = createPropertiesWeakMap<object, Properties>(getDefaults);\r\n *\r\n * console.log('obj before:', obj);\r\n * // {foo: \"bar\", isCoalescing: \"weakMap version\"}\r\n * console.log('props before:', propsMap.getProps(obj));\r\n * // {isCoalescing: \"weakMap version\"}\r\n *\r\n * propsMap.setProps(obj, {isCoalescing: true});\r\n * console.log('obj after:', obj);\r\n * // {foo: \"bar\", isCoalescing: \"weakMap version\"}\r\n * console.log('props after:', propsMap.getProps(obj));\r\n * // {isCoalescing: \"true\"}\r\n * */\r\nfunction createPropertiesWeakMap(getDefaults) {\r\n    const propertyMap = new WeakMap();\r\n    return {\r\n        getProps: getProperties,\r\n        setProps: setProperties\r\n    };\r\n    function getProperties(ctx) {\r\n        const defaults = getDefaults(ctx);\r\n        const propertiesPresent = propertyMap.get(ctx);\r\n        let properties;\r\n        if (propertiesPresent !== undefined) {\r\n            properties = propertiesPresent;\r\n        }\r\n        else {\r\n            properties = {};\r\n            Object.entries(defaults).forEach(([prop, value]) => {\r\n                properties[prop] = hasKey(ctx, prop) ? ctx[prop] : value;\r\n            });\r\n            propertyMap.set(ctx, properties);\r\n        }\r\n        return properties;\r\n    }\r\n    function setProperties(ctx, props) {\r\n        const properties = getProperties(ctx);\r\n        Object.entries(props).forEach(([prop, value]) => {\r\n            properties[prop] = value;\r\n        });\r\n        propertyMap.set(ctx, properties);\r\n        return properties;\r\n    }\r\n    function hasKey(ctx, property) {\r\n        return ctx[property] != null;\r\n    }\r\n}\n\n/**\r\n * envZonePatched\r\n *\r\n * @description\r\n *\r\n * This function checks the window object `zone.js` was instantiated.\r\n * If so, the `window` object maintains a property named `Zone`.\r\n *\r\n * Here how Angular checks it: https://github.com/angular/angular/blob/master/packages/core/src/zone/ng_zone.ts#L123\r\n *\r\n * @return {boolean} - true if `zone.js` patched global APIs.\r\n *\r\n */\r\nfunction envZonePatched() {\r\n    return getGlobalThis().Zone !== undefined;\r\n}\r\n/**\r\n * apiZonePatched\r\n *\r\n * @description\r\n *\r\n * This function checks if a specific Browser API is patched by `zone.js`.\r\n *\r\n * @param name {string} - The name of the API to check.\r\n * @return {boolean} - true if `zone.js` patched the API in question.\r\n *\r\n */\r\nfunction apiZonePatched(name) {\r\n    // if symbol is present, zone patched the API\r\n    return getGlobalThis()['__zone_symbol__' + name] !== undefined;\r\n}\r\nconst zoneDetectionCache = new WeakMap();\r\n/**\r\n * isNgZone\r\n *\r\n * @description\r\n *\r\n * This function takes an instance of a class which implements the NgZone interface and checks if\r\n * its `runOutsideAngular()` function calls `apply()` on the function passed as parameter. This\r\n * means the Angular application that instantiated this service assumes it runs in a ZoneLess\r\n * environment, and therefore it's change detection will not be triggered by zone related logic.\r\n *\r\n * However, keep in mind this does not mean `zone.js` is not present.\r\n * The environment could still run in ZoneFull mode even if Angular turned it off.\r\n * Consider the situation of a Angular element configured for ZoneLess\r\n * environments is used in an Angular application relining on the zone mechanism.\r\n *\r\n * @param instance {Class Instance} - The instance to check for constructor name of `NgZone`.\r\n * @return {boolean} - true if instance is of type `NgZone`.\r\n *\r\n */\r\nfunction isNgZone(instance) {\r\n    const cachedValue = zoneDetectionCache.get(instance);\r\n    if (cachedValue !== undefined) {\r\n        return cachedValue;\r\n    }\r\n    let calledApply = false;\r\n    function fn() { }\r\n    fn.apply = () => (calledApply = true);\r\n    instance.runOutsideAngular(fn);\r\n    zoneDetectionCache.set(instance, calledApply);\r\n    return calledApply;\r\n}\r\n/**\r\n * isNoopNgZone\r\n *\r\n *@description\r\n *\r\n * This function takes any instance of a class and checks\r\n * if the constructor name is equal to `NoopNgZone`.\r\n *\r\n * For more detailed information read the description of [isNgZone](#isngzone).\r\n *\r\n * @param instance {Class Instance} - The instance to check for constructor name of `NoopNgZone`.\r\n * @return {boolean} - true if instance is of type `NoopNgZone`.\r\n *\r\n */\r\nfunction isNoopNgZone(instance) {\r\n    return !isNgZone(instance);\r\n}\n\n/** A shared promise instance to cause a delay of one microtask */\r\nlet resolvedPromise = null;\r\nfunction getUnpatchedResolvedPromise() {\r\n    resolvedPromise =\r\n        resolvedPromise ||\r\n            (apiZonePatched('Promise')\r\n                ? getGlobalThis().__zone_symbol__Promise.resolve()\r\n                : Promise.resolve());\r\n    return resolvedPromise;\r\n}\n\n/**\r\n * envRunsIvy\r\n *\r\n * @description\r\n * Determines the used view engine of an Angular project is Ivy or not.\r\n * The check is done based on following table:\r\n * | render       | ViewEngine | ViewEngine | Ivy         | Ivy         |\r\n * | ------------ | ---------- | ---------- | ----------- | ----------- |\r\n * | **mode**     | prod       | dev        | prod        | dev         |\r\n * | **ng**       | present    | present    | `undefined` | present     |\r\n * | **ng.probe** | present    | present    | `undefined` | `undefined` |\r\n *\r\n *  So for Ivy we need to make sure that ng is undefined or,\r\n *  in case of dev environment, ng.probe is undefined.\r\n *\r\n * @return {boolean} - true if the used view engine is Ivy.\r\n *\r\n */\r\nfunction isViewEngineIvy() {\r\n    const ng = getGlobalThis().ng;\r\n    // Is the global ng object is unavailable?\r\n    // ng === undefined in Ivy production mode\r\n    // View Engine has the ng object both in development mode and production mode.\r\n    return (ng === undefined ||\r\n        // in case we are in dev mode in ivy\r\n        // `probe` property is available on ng object we use View Engine.\r\n        ng.probe === undefined);\r\n}\n\n/**\r\n * getZoneUnPatchedApi\r\n *\r\n * @description\r\n *\r\n * This function returns the zone un-patched API for the a specific Browser API.\r\n * If no element is passed the window is used instead\r\n *\r\n * @param name {string} - The name of the API to check.\r\n * @param elem {any} - The elem to get un-patched API from.\r\n * @return {Function} - The zone un-patched API in question.\r\n *\r\n */\r\nfunction getZoneUnPatchedApi(name, elem) {\r\n    elem = elem || getGlobalThis();\r\n    return apiZonePatched(name) ? elem['__zone_symbol__' + name] : elem[name];\r\n}\n\nconst coalescingManager = createCoalesceManager();\r\nconst ɵ0 = ctx => ({\r\n    numCoalescingSubscribers: 0\r\n});\r\nconst coalescingContextPropertiesMap = createPropertiesWeakMap(ɵ0);\r\nfunction createCoalesceManager() {\r\n    return {\r\n        remove: removeWork,\r\n        add: addWork,\r\n        isCoalescing\r\n    };\r\n    // Increments the number of subscriptions in a scope e.g. a class instance\r\n    function removeWork(scope = {}) {\r\n        const numCoalescingSubscribers = coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers -\r\n            1;\r\n        coalescingContextPropertiesMap.setProps(scope, {\r\n            numCoalescingSubscribers\r\n        });\r\n    }\r\n    // Decrements the number of subscriptions in a scope e.g. a class instance\r\n    function addWork(scope = {}) {\r\n        const numCoalescingSubscribers = coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers +\r\n            1;\r\n        coalescingContextPropertiesMap.setProps(scope, {\r\n            numCoalescingSubscribers\r\n        });\r\n    }\r\n    // Checks if anybody else is already coalescing atm\r\n    function isCoalescing(scope = {}) {\r\n        return (coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers >\r\n            0);\r\n    }\r\n}\n\n/**\r\n * @description\r\n * Limits the number of synchronous emitted a value from the source Observable to\r\n * one emitted value per\r\n *   [`AnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame), then repeats\r\n *   this process for every tick of the browsers event loop.\r\n *\r\n * The coalesce operator is based on the [throttle](https://rxjs-dev.firebaseapp.com/api/operators/throttle) operator.\r\n * In addition to that is provides emitted values for the trailing end only, as well as maintaining a context to scope\r\n *   coalescing.\r\n *\r\n * @param {function(value: T): SubscribableOrPromise} durationSelector - A function\r\n * that receives a value from the source Observable, for computing the silencing\r\n * duration for each source value, returned as an Observable or a Promise.\r\n * It defaults to `requestAnimationFrame` as durationSelector.\r\n * @param {Object} config - A configuration object to define `leading` and `trailing` behavior and the context object.\r\n * Defaults to `{ leading: false, trailing: true }`. The default scoping is per subscriber.\r\n * @return {Observable<T>} An Observable that performs the coalesce operation to\r\n * limit the rate of emissions from the source.\r\n *\r\n * @usageNotes\r\n * Emit clicks at a rate of at most one click per second\r\n * ```ts\r\n * import { fromEvent, animationFrames } from 'rxjs';\r\n * import { coalesce } from 'ngRx/component';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(coalesce(ev => animationFrames));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n */\r\nfunction coalesceWith(durationSelector, scope) {\r\n    const _scope = scope || {};\r\n    return source => {\r\n        const o$ = new Observable(observer => {\r\n            const rootSubscription = new Subscription();\r\n            rootSubscription.add(source.subscribe(createInnerObserver(observer, rootSubscription)));\r\n            return rootSubscription;\r\n        });\r\n        return o$;\r\n        function createInnerObserver(outerObserver, rootSubscription) {\r\n            let actionSubscription;\r\n            let latestValue;\r\n            const tryEmitLatestValue = () => {\r\n                coalescingManager.remove(_scope);\r\n                if (!coalescingManager.isCoalescing(_scope)) {\r\n                    outerObserver.next(latestValue);\r\n                }\r\n            };\r\n            return {\r\n                complete: () => {\r\n                    if (actionSubscription) {\r\n                        tryEmitLatestValue();\r\n                    }\r\n                    outerObserver.complete();\r\n                },\r\n                error: error => outerObserver.error(error),\r\n                next: value => {\r\n                    latestValue = value;\r\n                    if (!actionSubscription) {\r\n                        coalescingManager.add(_scope);\r\n                        actionSubscription = durationSelector.subscribe({\r\n                            next: () => {\r\n                                tryEmitLatestValue();\r\n                                actionSubscription = undefined;\r\n                            },\r\n                            complete: () => {\r\n                                if (actionSubscription) {\r\n                                    tryEmitLatestValue();\r\n                                    actionSubscription = undefined;\r\n                                }\r\n                            }\r\n                        });\r\n                        rootSubscription.add(actionSubscription);\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    };\r\n}\n\n/**\r\n * Noop Strategy\r\n *\r\n * This strategy is does nothing. It serves for debugging only\r\n *\r\n * | Name        | ZoneLess | Render Method | ScopedCoalescing | Scheduling | Chunked |\r\n * |-------------| ---------| --------------| ---------------- | ---------- |-------- |\r\n * | `noop`      | ❌       | ❌             | ❌                | ❌         | ❌      |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy} - The calculated strategy\r\n *\r\n */\r\nfunction createNoopStrategy() {\r\n    return {\r\n        name: 'noop',\r\n        detectChanges: () => { },\r\n        rxScheduleCD: o => o,\r\n        scheduleCD: () => new AbortController()\r\n    };\r\n}\n\n/**\r\n * Native Strategy\r\n * @description\r\n *\r\n * - mFC - `cdRef.markForCheck`\r\n *\r\n * This strategy mirrors Angular's built-in `async` pipe.\r\n * This means for every emitted value `ChangeDetectorRef#markForCheck` is called.\r\n *\r\n * | Name        | ZoneLess | Render Method | ScopedCoalescing | Scheduling | Chunked |\r\n * |-------------| ---------| --------------| ---------------- | ---------- |-------- |\r\n * | `native`    | ❌       | mFC           | ❌                | ❌         | ❌      |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy} - The calculated strategy\r\n *\r\n */\r\nfunction createNativeStrategy(config) {\r\n    const component = config.cdRef.context;\r\n    return {\r\n        name: 'native',\r\n        detectChanges: () => config.cdRef.markForCheck(),\r\n        rxScheduleCD: o => o.pipe(tap(() => ɵmarkDirty(component))),\r\n        scheduleCD: () => {\r\n            ɵmarkDirty(component);\r\n            return new AbortController();\r\n        }\r\n    };\r\n}\n\nfunction nameToStrategy(strategies) {\r\n    return (o$) => {\r\n        return o$.pipe(distinctUntilChanged(), map((strategy) => {\r\n            const s = strategies[strategy];\r\n            if (!!s) {\r\n                return s;\r\n            }\r\n            throw new Error(`Strategy ${strategy} does not exist.`);\r\n        }));\r\n    };\r\n}\n\n/**\r\n * RenderAware\r\n *\r\n * @description\r\n * This function returns an object that holds all the shared logic for the push pipe and the let directive\r\n * responsible for change detection\r\n * If you extend this class you need to implement how the update of the rendered value happens.\r\n * Also custom behaviour is something you need to implement in the extending class\r\n */\r\nfunction createRenderAware(cfg) {\r\n    const strategyName$ = new ReplaySubject(1);\r\n    let currentStrategy;\r\n    const strategy$ = strategyName$.pipe(distinctUntilChanged(), switchMap(stringOrObservable => typeof stringOrObservable === 'string'\r\n        ? of(stringOrObservable)\r\n        : stringOrObservable), nameToStrategy(cfg.strategies), tap(s => (currentStrategy = s)));\r\n    const observablesFromTemplate$ = new ReplaySubject(1);\r\n    const valuesFromTemplate$ = observablesFromTemplate$.pipe(distinctUntilChanged());\r\n    let firstTemplateObservableChange = true;\r\n    const renderingEffect$ = valuesFromTemplate$.pipe(\r\n    // handle null | undefined assignment and new Observable reset\r\n    map(observable$ => {\r\n        if (observable$ === null) {\r\n            return of(null);\r\n        }\r\n        if (!firstTemplateObservableChange) {\r\n            cfg.resetObserver.next();\r\n            if (observable$ === undefined) {\r\n                return of(undefined);\r\n            }\r\n        }\r\n        firstTemplateObservableChange = false;\r\n        return observable$;\r\n    }), \r\n    // forward only observable values\r\n    filter(o$ => o$ !== undefined), switchMap(o$ => o$.pipe(distinctUntilChanged(), tap(cfg.updateObserver), currentStrategy.rxScheduleCD, finalize(() => currentStrategy.scheduleCD()))), catchError(e => {\r\n        console.error(e);\r\n        return EMPTY;\r\n    }));\r\n    return {\r\n        nextPotentialObservable(value) {\r\n            observablesFromTemplate$.next(value);\r\n        },\r\n        nextStrategy(nextConfig) {\r\n            strategyName$.next(nextConfig);\r\n        },\r\n        activeStrategy$: strategy$,\r\n        subscribe() {\r\n            return new Subscription()\r\n                .add(strategy$.subscribe())\r\n                .add(renderingEffect$.subscribe());\r\n        }\r\n    };\r\n}\n\nfunction staticCoalesce(work, durationSelector, scope = {}, abC = new AbortController()) {\r\n    let sub;\r\n    if (!coalescingManager.isCoalescing(scope)) {\r\n        coalescingManager.add(scope);\r\n        sub = durationSelector.subscribe(() => {\r\n            tryExecuteWork();\r\n        });\r\n        const abortHandler = function () {\r\n            sub.unsubscribe();\r\n            abC.signal.removeEventListener('abort', abortHandler, false);\r\n        };\r\n        abC.signal.addEventListener('abort', abortHandler, false);\r\n    }\r\n    return abC;\r\n    // =====\r\n    function tryExecuteWork() {\r\n        coalescingManager.remove(scope);\r\n        if (!coalescingManager.isCoalescing(scope)) {\r\n            return work();\r\n        }\r\n    }\r\n}\n\nvar PostTaskSchedulerPriority;\r\n(function (PostTaskSchedulerPriority) {\r\n    PostTaskSchedulerPriority[\"background\"] = \"background\";\r\n    PostTaskSchedulerPriority[\"userBlocking\"] = \"user-blocking\";\r\n    PostTaskSchedulerPriority[\"userVisible\"] = \"user-visible\";\r\n})(PostTaskSchedulerPriority || (PostTaskSchedulerPriority = {}));\r\nconst postTaskScheduler = typeof window !== 'undefined'\r\n    ? window.scheduler || {\r\n        postTask(options) {\r\n            const start = Date.now();\r\n            return new Promise(resolve => {\r\n                setTimeout(function () {\r\n                    console.error('postTask not implemented. Use setTimeout as fallback');\r\n                    resolve();\r\n                }, 1);\r\n            });\r\n        }\r\n    }\r\n    : () => { };\n\nconst animationFrameTick = () => new Observable(subscriber => {\r\n    const id = getZoneUnPatchedApi('requestAnimationFrame')(() => {\r\n        subscriber.next(0);\r\n        subscriber.complete();\r\n    });\r\n    return () => {\r\n        getZoneUnPatchedApi('cancelAnimationFrame')(id);\r\n    };\r\n});\n\n// @NOTICE replace logic with 7v handling of promises in RxJS\r\nconst promiseTick = () => new Observable(subscriber => {\r\n    let cancelled = false;\r\n    getUnpatchedResolvedPromise()\r\n        .then(() => {\r\n        if (!cancelled) {\r\n            subscriber.next(0);\r\n            subscriber.complete();\r\n        }\r\n    })\r\n        .catch(e => {\r\n        subscriber.error(e);\r\n    });\r\n    return () => {\r\n        cancelled = true;\r\n        subscriber.complete();\r\n    };\r\n});\n\nconst timeoutTick = () => new Observable(subscriber => {\r\n    const id = window.__zone_symbol__setTimeout(() => {\r\n        subscriber.next(0);\r\n        subscriber.complete();\r\n    });\r\n    return () => {\r\n        window.__zone_symbol__clearTimeout(id);\r\n    };\r\n});\n\nconst cancelIdleCallback = typeof window !== 'undefined'\r\n    ? window.cancelIdleCallback ||\r\n        function (idleId) {\r\n            console.warn('Fake cancelIdleCallback used');\r\n            clearTimeout(idleId);\r\n        }\r\n    : () => { };\r\nconst requestIdleCallback = typeof window !== 'undefined'\r\n    ? window.requestIdleCallback ||\r\n        function (cb) {\r\n            console.warn('Fake requestIdleCallback used');\r\n            const start = Date.now();\r\n            return setTimeout(function () {\r\n                cb({\r\n                    didTimeout: false,\r\n                    timeRemaining: function () {\r\n                        return Math.max(0, 50 - (Date.now() - start));\r\n                    }\r\n                });\r\n            }, 1);\r\n        }\r\n    : () => { };\n\nconst idleCallbackTick = () => new Observable(subscriber => {\r\n    const id = requestIdleCallback(() => {\r\n        subscriber.next(0);\r\n        subscriber.complete();\r\n    });\r\n    return () => cancelIdleCallback(id);\r\n});\n\nconst postTaskTick = (options) => new Observable(subscription => {\r\n    postTaskScheduler\r\n        .postTask(() => { }, options)\r\n        .then(() => {\r\n        subscription.next(0);\r\n        subscription.complete();\r\n    });\r\n    return () => { };\r\n});\n\nconst priorityTickMap = {\r\n    animationFrame: animationFrameTick(),\r\n    Promise: promiseTick(),\r\n    setInterval: timeoutTick(),\r\n    idleCallback: idleCallbackTick(),\r\n    userBlocking: postTaskTick({\r\n        priority: PostTaskSchedulerPriority.userBlocking\r\n    }),\r\n    userVisible: postTaskTick({\r\n        priority: PostTaskSchedulerPriority.userVisible\r\n    }),\r\n    background: postTaskTick({ priority: PostTaskSchedulerPriority.background })\r\n};\n\nfunction staticSchedule(work, priority, abC = new AbortController()) {\r\n    // immediately execute work\r\n    if (priority === false) {\r\n        tryExecuteWork();\r\n        return abC;\r\n    }\r\n    // schedule work\r\n    const sub = priorityTickMap[priority].subscribe(() => tryExecuteWork(), error => console.error(error), \r\n    // on complete abort further executions\r\n    () => abC.abort());\r\n    const abortHandler = function () {\r\n        sub.unsubscribe();\r\n        abC.signal.removeEventListener('abort', abortHandler, false);\r\n    };\r\n    abC.signal.addEventListener('abort', abortHandler, false);\r\n    return abC;\r\n    // execute work and abort further executions\r\n    function tryExecuteWork() {\r\n        if (!abC.signal.aborted) {\r\n            work();\r\n            abC.abort();\r\n        }\r\n    }\r\n}\n\nfunction coalesceAndSchedule(work, priority, scope = {}, abC = new AbortController()) {\r\n    const durationSelector = from(getUnpatchedResolvedPromise());\r\n    const scheduledWork = () => staticSchedule(work, priority, abC);\r\n    const coalesceAbC = staticCoalesce(scheduledWork, durationSelector, scope, abC);\r\n    const abortHandler = function () {\r\n        coalesceAbC.abort();\r\n        abC.signal.removeEventListener('abort', abortHandler, false);\r\n    };\r\n    abC.signal.addEventListener('abort', abortHandler, false);\r\n    return abC;\r\n}\n\nvar SchedulingPriority;\r\n(function (SchedulingPriority) {\r\n    SchedulingPriority[\"animationFrame\"] = \"animationFrame\";\r\n    SchedulingPriority[\"Promise\"] = \"Promise\";\r\n    SchedulingPriority[\"idleCallback\"] = \"idleCallback\";\r\n    SchedulingPriority[\"userBlocking\"] = \"userBlocking\";\r\n    SchedulingPriority[\"userVisible\"] = \"userVisible\";\r\n    SchedulingPriority[\"background\"] = \"background\";\r\n    SchedulingPriority[\"setInterval\"] = \"setInterval\";\r\n})(SchedulingPriority || (SchedulingPriority = {}));\n\nconst promiseDurationSelector = promiseTick();\r\n/**\r\n * Experimental Local Strategies\r\n *\r\n * - ɵDC - `ɵdetectChanges`\r\n * - C - `Component`\r\n * - det - `cdRef.detach`\r\n * - ret - `cdRef.reattach`\r\n * - Pr - `Promise`\r\n * - aF - `requestAnimationFrame`\r\n *\r\n * | Name        | ZoneLess | Render Method | ScopedCoalescing | Scheduling | Chunked |\r\n * |-------------| ---------| --------------| ---------------- | ---------- |-------- |\r\n * | `local`     | ✔        | ɵDC           | C + Pr           | aF         | ❌      |\r\n * | `detach`    | ✔ ️     | ret,ɵDC, det  | C + Pr           | aF         | ❌      |\r\n *\r\n */\r\nfunction getLocalStrategies(config) {\r\n    return {\r\n        local: createLocalStrategy(config),\r\n        detach: createDetachStrategy(config)\r\n    };\r\n}\r\n/**\r\n *  Local Strategy\r\n *\r\n * This strategy is rendering the actual component and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * As detectChanges has no coalescing of render calls\r\n * like `ChangeDetectorRef#markForCheck` or `ɵmarkDirty` has, so we have to apply our own coalescing, 'scoped' on\r\n * component level.\r\n *\r\n * Coalescing, in this very manner,\r\n * means **collecting all events** in the same\r\n * [EventLoop](https://developer.mozilla.org/de/docs/Web/JavaScript/EventLoop) tick, that would cause a re-render and\r\n * execute **re-rendering only once**.\r\n *\r\n * 'Scoped' coalescing, in addition, means **grouping the collected events by** a specific context.\r\n * E. g. the **component** from which the re-rendering was initiated.\r\n *\r\n * | Name        | ZoneLess | Render Method | ScopedCoalescing | Scheduling | Chunked |\r\n * |-------------| ---------| --------------| ---------------- | ---------- |-------- |\r\n * | `local`     | ✔        | ɵDC           | C + Pr           | aF         | ❌      |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy} - The calculated strategy\r\n *\r\n */\r\nfunction createLocalStrategy(config) {\r\n    const component = config.cdRef.context;\r\n    const priority = SchedulingPriority.animationFrame;\r\n    const tick = priorityTickMap[priority];\r\n    const renderMethod = () => {\r\n        ɵdetectChanges(component);\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(promiseDurationSelector, component), switchMap(v => tick.pipe(map(() => v))), tap(renderMethod));\r\n    const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, component);\r\n    return {\r\n        name: 'local',\r\n        detectChanges: renderMethod,\r\n        rxScheduleCD: behavior,\r\n        scheduleCD\r\n    };\r\n}\r\n/**\r\n *  Detach Strategy\r\n *\r\n * This strategy is rendering the actual component and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * As detectChanges has no coalescing of render calls\r\n * like `ChangeDetectorRef#markForCheck` or `ɵmarkDirty` has, so we have to apply our own coalescing, 'scoped' on\r\n * component level.\r\n *\r\n * Coalescing, in this very manner,\r\n * means **collecting all events** in the same\r\n * [EventLoop](https://developer.mozilla.org/de/docs/Web/JavaScript/EventLoop) tick, that would cause a re-render and\r\n * execute **re-rendering only once**.\r\n *\r\n * 'Scoped' coalescing, in addition, means **grouping the collected events by** a specific context.\r\n * E. g. the **component** from which the re-rendering was initiated.\r\n *\r\n * | Name        | ZoneLess | Render Method | ScopedCoalescing | Scheduling | Chunked |\r\n * |-------------| ---------| --------------| ---------------- | ---------- |-------- |\r\n * | `detach`    | ✔ ️     | ret,ɵDC, det  | C + Pr           | aF         | ❌      |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy} - The calculated strategy\r\n *\r\n */\r\nfunction createDetachStrategy(config) {\r\n    const component = config.cdRef.context;\r\n    const priority = SchedulingPriority.animationFrame;\r\n    const tick = priorityTickMap[priority];\r\n    const renderMethod = () => {\r\n        config.cdRef.reattach();\r\n        ɵdetectChanges(component);\r\n        config.cdRef.detach();\r\n    };\r\n    const behavior = o => o.pipe(coalesceWith(promiseDurationSelector, component), switchMap(v => tick.pipe(map(() => v))), tap(renderMethod));\r\n    const scheduleCD = () => coalesceAndSchedule(renderMethod, priority, component);\r\n    return {\r\n        name: 'detach',\r\n        detectChanges: renderMethod,\r\n        rxScheduleCD: behavior,\r\n        scheduleCD\r\n    };\r\n}\n\nfunction getGlobalStrategies(config) {\r\n    return {\r\n        global: createGlobalStrategy(config)\r\n    };\r\n}\r\n/**\r\n * Global Strategies\r\n *\r\n * - ɵMD - `ɵmarkDirty`\r\n * - C - `Component`\r\n *\r\n * | Name        | ZoneLess | Render Method | ScopedCoalescing | Scheduling | Chunked |\r\n * |-------------| ---------| --------------| ---------------- | ---------- |-------- |\r\n * | `global`     | ✔        | ɵMD           | C + Pr          | ❌         | ❌      |\r\n *\r\n */\r\n/**\r\n *\r\n * Global Strategy\r\n *\r\n * This strategy is rendering the application root and\r\n * all it's children that are on a path\r\n * that is marked as dirty or has components with `ChangeDetectionStrategy.Default`.\r\n *\r\n * | Name        | ZoneLess | Render Method | ScopedCoalescing | Scheduling | Chunked |\r\n * |-------------| ---------| --------------| ---------------- | ---------- |-------- |\r\n * | `global`     | ✔        | ɵMD           | C + Pr          | ❌         | ❌      |\r\n *\r\n * @param config { RenderStrategyFactoryConfig } - The values this strategy needs to get calculated.\r\n * @return {RenderStrategy<T>} - The calculated strategy\r\n *\r\n */\r\nfunction createGlobalStrategy(config) {\r\n    const renderMethod = () => ɵmarkDirty(config.cdRef.context);\r\n    return {\r\n        name: 'global',\r\n        detectChanges: renderMethod,\r\n        rxScheduleCD: o => o,\r\n        scheduleCD: () => {\r\n            renderMethod();\r\n            return new AbortController();\r\n        }\r\n    };\r\n}\n\nconst DEFAULT_STRATEGY_NAME = 'local';\r\nfunction getStrategies(config) {\r\n    return Object.assign(Object.assign({ noop: createNoopStrategy(), native: createNativeStrategy(config) }, getGlobalStrategies(config)), getLocalStrategies(config));\r\n}\r\n/**\r\n * Strategies\r\n *\r\n * - mFC - `cdRef.markForCheck`\r\n * - dC - `cdRef.detectChanges`\r\n * - ɵMD - `ɵmarkDirty`\r\n * - ɵDC - `ɵdetectChanges`\r\n * - C - `Component`\r\n * - det - `cdRef.detach`\r\n * - ret - `cdRef.reattach`\r\n * - Pr - `Promise`\r\n * - aF - `requestAnimationFrame`\r\n *\r\n * | Name        | ZoneLess | Render Method | ScopedCoalescing | Scheduling | Chunked |\r\n * |-------------| ---------| --------------| ---------------- | ---------- |-------- |\r\n * | `noop`      | ❌       | ❌             | ❌               | ❌         | ❌       |\r\n * | `native`    | ❌       | mFC           | ❌                | ❌         | ❌      |\r\n * | `global`    | ✔        | ɵMD           | C + Pr           | ❌         | ❌      |\r\n * | `local`     | ✔        | ɵDC           | C + Pr           | aF         | ❌      |\r\n * | `detach`    | ✔ ️     | ret,ɵDC, det  | C + Pr           | aF         | ❌      |\r\n */\n\nfunction renderChange(cdRef, strategyName) {\r\n    const strategies = getStrategies({ cdRef });\r\n    const strategy = strategies[strategyName];\r\n    return o => o.pipe(strategy.rxScheduleCD);\r\n}\n\n/**\r\n * @Pipe PushPipe\r\n *\r\n * @description\r\n *\r\n * The `push` pipe serves as a drop-in replacement for the `async` pipe.\r\n * It contains intelligent handling of change detection to enable us\r\n * running in zone-full as well as zone-less mode without any changes to the code.\r\n *\r\n * The current way of binding an observable to the view looks like that:\r\n *  ```html\r\n *  {{observable$ | async}}\r\n * <ng-container *ngIf=\"observable$ | async as o\">{{o}}</ng-container>\r\n * <component [value]=\"observable$ | async\"></component>\r\n * ```\r\n *\r\n * The problem is `async` pipe just marks the component and all its ancestors as dirty.\r\n * It needs zone.js microtask queue to exhaust until `ApplicationRef.tick` is called to render all dirty marked\r\n *     components.\r\n *\r\n * Heavy dynamic and interactive UIs suffer from zones change detection a lot and can\r\n * lean to bad performance or even unusable applications, but the `async` pipe does not work in zone-less mode.\r\n *\r\n * `push` pipe solves that problem.\r\n *\r\n * Included Features:\r\n *  - Take observables or promises, retrieve their values and render the value to the template\r\n *  - Handling null and undefined values in a clean unified/structured way\r\n *  - Triggers change-detection differently if `zone.js` is present or not (`detectChanges` or `markForCheck`)\r\n *  - Distinct same values in a row to increase performance\r\n *  - Coalescing of change detection calls to boost performance\r\n *\r\n * @usageNotes\r\n *\r\n * `push` pipe solves that problem. It can be used like shown here:\r\n * ```html\r\n * {{observable$ | push}}\r\n * <ng-container *ngIf=\"observable$ | push as o\">{{o}}</ng-container>\r\n * <component [value]=\"observable$ | push\"></component>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nclass PushPipe {\r\n    constructor(cdRef) {\r\n        this.resetObserver = {\r\n            next: () => {\r\n                this.renderedValue = undefined;\r\n            }\r\n        };\r\n        this.updateObserver = {\r\n            next: (value) => (this.renderedValue = value)\r\n        };\r\n        this.RenderAware = createRenderAware({\r\n            strategies: getStrategies({\r\n                cdRef\r\n            }),\r\n            updateObserver: this.updateObserver,\r\n            resetObserver: this.resetObserver\r\n        });\r\n        this.subscription = this.RenderAware.subscribe();\r\n    }\r\n    transform(potentialObservable, config) {\r\n        const strategy = config || DEFAULT_STRATEGY_NAME;\r\n        this.RenderAware.nextStrategy(strategy);\r\n        this.RenderAware.nextPotentialObservable(potentialObservable);\r\n        return this.renderedValue;\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscription.unsubscribe();\r\n    }\r\n}\nPushPipe.ɵfac = function PushPipe_Factory(t) { return new (t || PushPipe)(ɵngcc0.ɵɵinjectPipeChangeDetectorRef()); };\nPushPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: \"push\", type: PushPipe, pure: false });\r\nPushPipe.ctorParameters = () => [\r\n    { type: ChangeDetectorRef }\r\n];\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PushPipe, [{\n        type: Pipe,\n        args: [{ name: 'push', pure: false }]\n    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, null); })();\r\nPushPipe.ctorParameters = () => [\r\n    { type: ChangeDetectorRef }\r\n];\n\nconst DECLARATIONS = [PushPipe];\r\nclass PushModule {\r\n}\nPushModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PushModule });\nPushModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function PushModule_Factory(t) { return new (t || PushModule)(); }, imports: [[]] });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PushModule, { declarations: [PushPipe], exports: [PushPipe] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PushModule, [{\n        type: NgModule,\n        args: [{\n                declarations: DECLARATIONS,\n                imports: [],\n                exports: DECLARATIONS\n            }]\n    }], null, null); })();\n\nclass TemplateManager {\r\n    constructor(viewContainerRef, initialViewContext) {\r\n        this.viewContainerRef = viewContainerRef;\r\n        this.templateCache = new Map();\r\n        this.viewCache = new Map();\r\n        this.viewContext = Object.assign({}, initialViewContext);\r\n    }\r\n    updateViewContext(viewContextSlice) {\r\n        Object.entries(viewContextSlice).forEach(([key, value]) => {\r\n            this.viewContext[key] = value;\r\n        });\r\n    }\r\n    addTemplateRef(name, templateRef) {\r\n        assertTemplate(name, templateRef);\r\n        this.templateCache.set(name, templateRef);\r\n    }\r\n    insertEmbeddedView(name) {\r\n        if (this.templateCache.has(name)) {\r\n            this.viewContainerRef.detach();\r\n            if (this.viewCache.has(name)) {\r\n                this.viewContainerRef.insert(this.viewCache.get(name));\r\n            }\r\n            else {\r\n                const newView = this.viewContainerRef.createEmbeddedView(this.templateCache.get(name), this.viewContext);\r\n                this.viewCache.set(name, newView);\r\n            }\r\n        }\r\n    }\r\n    destroy() {\r\n        this.viewCache.forEach(embeddedView => embeddedView === null || embeddedView === void 0 ? void 0 : embeddedView.destroy());\r\n        this.viewContainerRef.clear();\r\n    }\r\n}\r\nfunction assertTemplate(property, templateRef) {\r\n    const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);\r\n    if (!isTemplateRefOrNull) {\r\n        throw new Error(`${property} must be a TemplateRef, but received something else.`);\r\n    }\r\n    return isTemplateRefOrNull;\r\n}\n\n/**\r\n * @Directive LetDirective\r\n *\r\n * @description\r\n *\r\n * The `*rxLet` directive serves a convenient way of binding observables to a view context (a dom element scope).\r\n * It also helps with several internal processing under the hood.\r\n *\r\n * The current way of binding an observable to the view looks like that:\r\n * ```html\r\n * <ng-container *ngIf=\"observableNumber$ as n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * <app-number-special [number]=\"n\">\r\n * </app-number-special>\r\n * </ng-container>\r\n *  ```\r\n *\r\n *  The problem is `*ngIf` is also interfering with rendering and in case of a `0` the component would be hidden\r\n *\r\n * Included Features:\r\n * - binding is always present. (`*ngIf=\"truthy$\"`)\r\n * - it takes away the multiple usages of the `async` or `push` pipe\r\n * - a unified/structured way of handling null and undefined\r\n * - triggers change-detection differently if `zone.js` is present or not (`ChangeDetectorRef.detectChanges` or\r\n *   `ChangeDetectorRef.markForCheck`)\r\n * - triggers change-detection differently if ViewEngine or Ivy is present (`ChangeDetectorRef.detectChanges` or\r\n *   `ɵdetectChanges`)\r\n * - distinct same values in a row (distinctUntilChanged operator),\r\n *\r\n * @usageNotes\r\n *\r\n * The `*rxLet` directive take over several things and makes it more convenient and save to work with streams in the\r\n *   template\r\n * `<ng-container *rxLet=\"observableNumber$ as c\"></ng-container>`\r\n *\r\n * ```html\r\n * <ng-container *rxLet=\"observableNumber$ as n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * </ng-container>\r\n *\r\n * <ng-container *rxLet=\"observableNumber$; let n\">\r\n * <app-number [number]=\"n\">\r\n * </app-number>\r\n * </ng-container>\r\n * ```\r\n *\r\n * In addition to that it provides us information from the whole observable context.\r\n * We can track the observables:\r\n * - next value\r\n * - error value\r\n * - complete base-state\r\n *\r\n * ```html\r\n * <ng-container *rxLet=\"observableNumber$; let n; let e = $error, let c = $complete\">\r\n * <app-number [number]=\"n\"  *ngIf=\"!e && !c\">\r\n * </app-number>\r\n * <ng-container *ngIf=\"e\">\r\n * There is an error: {{e}}\r\n * </ng-container>\r\n * <ng-container *ngIf=\"c\">\r\n * Observable completed: {{c}}\r\n * </ng-container>\r\n * </ng-container>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nclass LetDirective {\r\n    constructor(cdRef, nextTemplateRef, viewContainerRef) {\r\n        this.nextTemplateRef = nextTemplateRef;\r\n        this.viewContainerRef = viewContainerRef;\r\n        this.resetObserver = {\r\n            next: () => {\r\n                this.templateManager.updateViewContext({\r\n                    $implicit: undefined,\r\n                    rxLet: undefined,\r\n                    $error: false,\r\n                    $complete: false\r\n                });\r\n            }\r\n        };\r\n        this.updateObserver = {\r\n            next: (value) => {\r\n                this.templateManager.insertEmbeddedView('rxNext');\r\n                this.templateManager.updateViewContext({\r\n                    $implicit: value,\r\n                    rxLet: value\r\n                });\r\n            },\r\n            error: (error) => {\r\n                // fallback to rxNext when there's no template for rxError\r\n                this.templateManager.insertEmbeddedView('rxNext');\r\n                this.templateManager.insertEmbeddedView('rxError');\r\n                this.templateManager.updateViewContext({\r\n                    $error: true\r\n                });\r\n            },\r\n            complete: () => {\r\n                // fallback to rxNext when there's no template for rxComplete\r\n                this.templateManager.insertEmbeddedView('rxNext');\r\n                this.templateManager.insertEmbeddedView('rxComplete');\r\n                this.templateManager.updateViewContext({\r\n                    $complete: true\r\n                });\r\n            }\r\n        };\r\n        this.strategies = getStrategies({ cdRef });\r\n        this.templateManager = new TemplateManager(this.viewContainerRef, {\r\n            $implicit: undefined,\r\n            rxLet: undefined,\r\n            $error: false,\r\n            $complete: false\r\n        });\r\n        this.renderAware = createRenderAware({\r\n            strategies: this.strategies,\r\n            resetObserver: this.resetObserver,\r\n            updateObserver: this.updateObserver\r\n        });\r\n        this.renderAware.nextStrategy(DEFAULT_STRATEGY_NAME);\r\n    }\r\n    set rxLet(potentialObservable) {\r\n        this.renderAware.nextPotentialObservable(potentialObservable);\r\n    }\r\n    set strategy(strategy) {\r\n        this.renderAware.nextStrategy(strategy || DEFAULT_STRATEGY_NAME);\r\n    }\r\n    set rxLetComplete(templateRef) {\r\n        this.templateManager.addTemplateRef('rxComplete', templateRef);\r\n    }\r\n    set rxLetError(templateRef) {\r\n        this.templateManager.addTemplateRef('rxError', templateRef);\r\n    }\r\n    set rxLetSuspense(templateRef) {\r\n        this.templateManager.addTemplateRef('rxSuspense', templateRef);\r\n    }\r\n    static ngTemplateContextGuard(dir, ctx) {\r\n        return true;\r\n    }\r\n    ngOnInit() {\r\n        this.templateManager.insertEmbeddedView('rxSuspense');\r\n        this.templateManager.addTemplateRef('rxNext', this.nextTemplateRef);\r\n        this.subscription = this.renderAware.subscribe();\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscription.unsubscribe();\r\n        this.templateManager.destroy();\r\n    }\r\n}\nLetDirective.ɵfac = function LetDirective_Factory(t) { return new (t || LetDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };\nLetDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LetDirective, selectors: [[\"\", \"rxLet\", \"\"]], inputs: { rxLet: \"rxLet\", strategy: [\"rxLetStrategy\", \"strategy\"], rxLetComplete: \"rxLetComplete\", rxLetError: \"rxLetError\", rxLetSuspense: \"rxLetSuspense\" }, exportAs: [\"renderNotifier\"] });\r\nLetDirective.ctorParameters = () => [\r\n    { type: ChangeDetectorRef },\r\n    { type: TemplateRef },\r\n    { type: ViewContainerRef }\r\n];\r\nLetDirective.ctorParameters = () => [\r\n    { type: ChangeDetectorRef },\r\n    { type: TemplateRef },\r\n    { type: ViewContainerRef }\r\n];\r\nLetDirective.propDecorators = {\r\n    rxLet: [{ type: Input }],\r\n    strategy: [{ type: Input, args: ['rxLetStrategy',] }],\r\n    rxLetComplete: [{ type: Input }],\r\n    rxLetError: [{ type: Input }],\r\n    rxLetSuspense: [{ type: Input }]\r\n};\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LetDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[rxLet]',\n                exportAs: 'renderNotifier'\n            }]\n    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }]; }, { rxLet: [{\n            type: Input\n        }], strategy: [{\n            type: Input,\n            args: ['rxLetStrategy']\n        }], rxLetComplete: [{\n            type: Input\n        }], rxLetError: [{\n            type: Input\n        }], rxLetSuspense: [{\n            type: Input\n        }] }); })();\n\nconst EXPORTED_DECLARATIONS = [LetDirective];\r\nclass LetModule {\r\n}\nLetModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LetModule });\nLetModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function LetModule_Factory(t) { return new (t || LetModule)(); } });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LetModule, { declarations: [LetDirective], exports: [LetDirective] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LetModule, [{\n        type: NgModule,\n        args: [{\n                declarations: EXPORTED_DECLARATIONS,\n                exports: [EXPORTED_DECLARATIONS]\n            }]\n    }], null, null); })();\n\nconst zonePatchedEvents = [\r\n    'scroll',\r\n    'mousedown',\r\n    'mouseenter',\r\n    'mouseleave',\r\n    'mousemove',\r\n    'mouseout',\r\n    'mouseover',\r\n    'mouseup',\r\n    'load',\r\n    'pointerup',\r\n    'change',\r\n    'blur',\r\n    'focus',\r\n    'click',\r\n    'contextmenu',\r\n    'drag',\r\n    'dragend',\r\n    'dragenter',\r\n    'dragleave',\r\n    'dragover',\r\n    'dragstart',\r\n    'drop',\r\n    'input'\r\n];\n\n/**\r\n *\r\n * @description\r\n *\r\n * This function takes an elem and event and re-applies the listeners from the passed event to the\r\n * passed element with the zone un-patched version of it.\r\n *\r\n * @param elem {HTMLElement} - The elem to re-apply the listeners to.\r\n * @param event {string} - The name of the event from which to re-apply the listeners.\r\n *\r\n * @returns void\r\n */\r\nfunction unpatchEventListener(elem, event) {\r\n    const eventListeners = elem.eventListeners(event);\r\n    // Return if no event listeners are present\r\n    if (!eventListeners) {\r\n        return;\r\n    }\r\n    const addEventListener = getZoneUnPatchedApi('addEventListener', elem).bind(elem);\r\n    eventListeners.forEach(listener => {\r\n        // Remove and reapply listeners with patched API\r\n        elem.removeEventListener(event, listener);\r\n        // Reapply listeners with un-patched API\r\n        addEventListener(event, listener);\r\n    });\r\n}\r\n/**\r\n * @Directive UnpatchEventsDirective\r\n *\r\n * @description\r\n *\r\n * The `unpatch` directive helps in partially migrating to zone-less apps as well as getting rid\r\n * of unnecessary renderings through zones `addEventListener` patches.\r\n * It can be used on any element you apply event bindings.\r\n *\r\n * The current way of binding events to the DOM is to use output bindings:\r\n *  ```html\r\n * <button (click)=\"doStuff($event)\">click me</button>\r\n * ```\r\n *\r\n * The problem is that every event registered over `()` syntax, e.g. `(click)`\r\n * marks the component and all its ancestors as dirty and re-renders the whole component tree.\r\n * This is because zone.js patches the native browser API and whenever one of the patched APIs is used it re-renders.\r\n *\r\n * So even if your button is not related to a change that needs a re-render the app will re-render completely.\r\n * This leads to bad performance. This is especially helpful if you work with frequently fired events like 'mousemove'\r\n *\r\n * `unpatch` directive solves that problem.\r\n *\r\n * Included Features:\r\n *  - by default un-patch all registered listeners of the host it is applied on\r\n *  - un-patch only a specified set of registered event listeners\r\n *  - works zone independent (it directly checks the widow for patched APIs and un-patches them without the use of `runOutsideZone` which brings more performance)\r\n *  - Not interfering with any logic executed by the registered callback\r\n *\r\n * @usageNotes\r\n *\r\n * The `unpatch` directive can be used like shown here:\r\n * ```html\r\n * <button [unoatch] (click)=\"triggerSomeMethod($event)\">click me</button>\r\n * <button [unoatch]=\"['mousemove']\" (mousemove)=\"doStuff2($event)\" (click)=\"doStuff($event)\">click me</button>\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\n// tslint:disable-next-line:directive-selector\r\nclass UnpatchEventsDirective {\r\n    constructor(el) {\r\n        this.el = el;\r\n        this.subscription = new Subscription();\r\n        this.events$ = new BehaviorSubject(zonePatchedEvents);\r\n    }\r\n    set events(value) {\r\n        if (value && value.length > 0) {\r\n            this.events$.next(value);\r\n        }\r\n        else {\r\n            this.events$.next(zonePatchedEvents);\r\n        }\r\n    }\r\n    reapplyEventListenersZoneUnPatched(events) {\r\n        events.forEach(ev => {\r\n            unpatchEventListener(this.el.nativeElement, ev);\r\n        });\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscription.unsubscribe();\r\n    }\r\n    ngAfterViewInit() {\r\n        this.subscription = this.events$\r\n            .pipe(tap(eventList => this.reapplyEventListenersZoneUnPatched(eventList)))\r\n            .subscribe();\r\n    }\r\n}\nUnpatchEventsDirective.ɵfac = function UnpatchEventsDirective_Factory(t) { return new (t || UnpatchEventsDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\nUnpatchEventsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: UnpatchEventsDirective, selectors: [[\"\", \"unpatch\", \"\"]], inputs: { events: [\"unpatch\", \"events\"] } });\r\nUnpatchEventsDirective.ctorParameters = () => [\r\n    { type: ElementRef }\r\n];\r\nUnpatchEventsDirective.ctorParameters = () => [\r\n    { type: ElementRef }\r\n];\r\nUnpatchEventsDirective.propDecorators = {\r\n    events: [{ type: Input, args: ['unpatch',] }]\r\n};\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UnpatchEventsDirective, [{\n        type: Directive,\n        args: [{ selector: '[unpatch]' }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { events: [{\n            type: Input,\n            args: ['unpatch']\n        }] }); })();\n\nconst DECLARATIONS$1 = [UnpatchEventsDirective];\r\nclass UnpatchEventsModule {\r\n}\nUnpatchEventsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: UnpatchEventsModule });\nUnpatchEventsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function UnpatchEventsModule_Factory(t) { return new (t || UnpatchEventsModule)(); } });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(UnpatchEventsModule, { declarations: [UnpatchEventsDirective], exports: [UnpatchEventsDirective] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UnpatchEventsModule, [{\n        type: NgModule,\n        args: [{\n                declarations: DECLARATIONS$1,\n                exports: DECLARATIONS$1\n            }]\n    }], null, null); })();\n\n/**\r\n *\r\n * @description\r\n *\r\n * This function takes an elem and event and re-applies the listeners from the passed event to the\r\n * passed element with the zone un-patched version of it.\r\n *\r\n * @param elem {HTMLElement} - The elem to re-apply the listeners to.\r\n * @param event {string} - The name of the event from which to re-apply the listeners.\r\n *\r\n * @returns void\r\n */\r\nfunction unpatchEventListener$1(elem, event) {\r\n    const eventListeners = elem.eventListeners(event);\r\n    // Return if no event listeners are present\r\n    if (!eventListeners) {\r\n        return;\r\n    }\r\n    const addEventListener = getZoneUnPatchedApi('addEventListener', elem).bind(elem);\r\n    eventListeners.forEach(listener => {\r\n        // Remove and reapply listeners with patched API\r\n        elem.removeEventListener(event, listener);\r\n        // Reapply listeners with un-patched API\r\n        addEventListener(event, listener);\r\n    });\r\n}\r\nfunction intersectionObserver(options) {\r\n    const subject = new Subject();\r\n    const observer = observerSupported()\r\n        ? new IntersectionObserver(entries => {\r\n            entries.forEach(entry => subject.next(entry));\r\n        }, options)\r\n        : null;\r\n    const entries$ = new Observable(subscriber => {\r\n        subject.subscribe(subscriber);\r\n        return () => {\r\n            if (observer) {\r\n                observer.disconnect();\r\n            }\r\n        };\r\n    });\r\n    return {\r\n        entries$,\r\n        observe: observer.observe,\r\n        unobserve: observer.unobserve\r\n    };\r\n}\r\nconst observerSupported = () => typeof window !== 'undefined'\r\n    ? !!window.IntersectionObserver\r\n    : false;\r\nconst ɵ0$1 = observerSupported;\r\nclass ViewportPrioDirective {\r\n    constructor(el, letDirective) {\r\n        this.el = el;\r\n        this.letDirective = letDirective;\r\n        this.entriesSubject = new Subject();\r\n        this.entries$ = this.entriesSubject.pipe(mergeAll());\r\n        this._viewportPrio = 'noop';\r\n        this.observer = observerSupported()\r\n            ? new IntersectionObserver(entries => this.entriesSubject.next(entries), {\r\n                threshold: 0\r\n            })\r\n            : null;\r\n        this.visibilityEvents$ = this.entries$.pipe(map(entry => {\r\n            if (entry.intersectionRatio > 0) {\r\n                return 'visible';\r\n            }\r\n            else {\r\n                return 'invisible';\r\n            }\r\n        }));\r\n    }\r\n    set viewportPrio(prio) {\r\n        if (prio) {\r\n            this._viewportPrio = prio || 'noop';\r\n        }\r\n    }\r\n    ngOnInit() {\r\n        const letStrategyName$ = this.letDirective.renderAware.activeStrategy$.pipe(map(s => s.name), filter(name => name !== this._viewportPrio));\r\n        this.observer.observe(this.el.nativeElement);\r\n        this.visibilityEvents$\r\n            .pipe(withLatestFrom(letStrategyName$), map(([visibility, strategyName]) => visibility === 'visible' ? strategyName : this._viewportPrio))\r\n            .subscribe(strategyName => {\r\n            this.letDirective.strategy = strategyName;\r\n            // render actual state on viewport enter\r\n            this.letDirective.strategies[strategyName].scheduleCD();\r\n            //\r\n            this.el.nativeElement.classList.add(strategyName);\r\n        });\r\n    }\r\n}\nViewportPrioDirective.ɵfac = function ViewportPrioDirective_Factory(t) { return new (t || ViewportPrioDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(LetDirective, 8)); };\nViewportPrioDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ViewportPrioDirective, selectors: [[\"\", \"viewport-prio\", \"\"]], inputs: { viewportPrio: [\"viewport-prio\", \"viewportPrio\"] } });\r\nViewportPrioDirective.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: LetDirective, decorators: [{ type: Optional }] }\r\n];\r\nViewportPrioDirective.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: LetDirective, decorators: [{ type: Optional }] }\r\n];\r\nViewportPrioDirective.propDecorators = {\r\n    viewportPrio: [{ type: Input, args: ['viewport-prio',] }]\r\n};\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ViewportPrioDirective, [{\n        type: Directive,\n        args: [{\n                // tslint:disable-next-line:directive-selector\n                selector: '[viewport-prio]'\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: LetDirective, decorators: [{\n                type: Optional\n            }] }]; }, { viewportPrio: [{\n            type: Input,\n            args: ['viewport-prio']\n        }] }); })();\n\nconst DECLARATIONS$2 = [ViewportPrioDirective];\r\nclass ViewportPrioModule {\r\n}\nViewportPrioModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ViewportPrioModule });\nViewportPrioModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ViewportPrioModule_Factory(t) { return new (t || ViewportPrioModule)(); } });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ViewportPrioModule, { declarations: [ViewportPrioDirective], exports: [ViewportPrioDirective] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ViewportPrioModule, [{\n        type: NgModule,\n        args: [{\n                declarations: DECLARATIONS$2,\n                exports: DECLARATIONS$2\n            }]\n    }], null, null); })();\n\nclass TemplateModule {\r\n}\nTemplateModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TemplateModule });\nTemplateModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TemplateModule_Factory(t) { return new (t || TemplateModule)(); }, imports: [LetModule, PushModule, UnpatchEventsModule, ViewportPrioModule] });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TemplateModule, { exports: [LetModule, PushModule, UnpatchEventsModule, ViewportPrioModule] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TemplateModule, [{\n        type: NgModule,\n        args: [{\n                exports: [LetModule, PushModule, UnpatchEventsModule, ViewportPrioModule]\n            }]\n    }], null, null); })();\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { LetDirective, LetModule, PushModule, PushPipe, SchedulingPriority, TemplateModule, UnpatchEventsDirective, UnpatchEventsModule, ViewportPrioDirective, ViewportPrioModule, getStrategies, getZoneUnPatchedApi, isNgZone, isViewEngineIvy, priorityTickMap };\n\n//# sourceMappingURL=rx-angular-template.js.map","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RenderingWorkModule } from '../../../shared/debug-helper/rendering-work/rendering-work.module';\nimport { RouterModule } from '@angular/router';\nimport { MatButtonModule } from '@angular/material/button';\nimport { AlphasCompareComponent } from './alphas-compare.component';\nimport { ROUTES as ALPHAS_COMPARE_ROUTES } from './alphas-compare.routes';\nimport { Alpha0ToggleModule } from './alpha-0-toggle/alpha-0-toggle.module';\nimport { Alpha1ToggleModule } from './alpha-1-toggle/alpha-1-toggle.module';\nimport { UnpatchEventsModule } from 'templateAlpha1';\n\n@NgModule({\n  declarations: [AlphasCompareComponent],\n  imports: [\n    CommonModule,\n    RenderingWorkModule,\n    MatButtonModule,\n    RouterModule.forChild(ALPHAS_COMPARE_ROUTES),\n    Alpha0ToggleModule,\n    Alpha1ToggleModule,\n    UnpatchEventsModule\n  ]\n})\nexport class AlphasCompareModule {}\n"],"sourceRoot":"webpack:///"}